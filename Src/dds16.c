//******************************************************************************
// Секция include: здесь подключается заголовочный файл к модулю
//******************************************************************************
#include "dds16.h" // Включаем файл заголовка для нашего модуля
//******************************************************************************
// Секция определения переменных, используемых в модуле
//******************************************************************************
//------------------------------------------------------------------------------
// Глобальные
//------------------------------------------------------------------------------
//char GlobalVar1;
//char GlobalVar2;
//...
//------------------------------------------------------------------------------
// Локальные
//------------------------------------------------------------------------------
//static char LocalVar1;
//static char LocalVar2;
//...
//******************************************************************************
// Секция прототипов локальных функций
//******************************************************************************
//void local_func1 (void);
//void local_func2 (void);
//...
//******************************************************************************
// Секция описания функций (сначала глобальных, потом локальных)
//******************************************************************************
void dds16 (DDS16_t *D) {

      if ((D->Fdiskr == 0) || (D->Fdiskr >=65535))  return;                     // Ошибка. Неинициализирована частота дискретизации
      
      D->temp = ((D->Freq << 16) / D->Fdiskr);                                  // Получаем прибавку к мгновенной фазе для текущей частоты
      D->Phase += D->temp;                                                      // Получаем новую мгновенную фазу
      D->Phase &= 0xFFFF;                                                       // Усекаем фазовый аккумулятор до 16 бит
      D->ptr = Sin_q16_table;                                                   // Получаем адрес начала таблицы синуса
      
      //------------------------------------------------------------------------ I
      if ((D->Phase) < 0x3FFF) {
        D->ptr += D->Phase;                                                     // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->I = *(D->ptr);                                                       // Получаем значение новой мгновенной амплитуды 
      }
      //------------------------------------------------------------------------ II
      if (((D->Phase) >= 0x3FFF) && ((D->Phase) < 0x7FFF)){
        D->ptr += 0x3FFF - (D->Phase - 0x3FFF);                                 // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->I = *(D->ptr);                                                       // Получаем значение новой мгновенной амплитуды 
      }
      //------------------------------------------------------------------------ III
      if ((D->Phase >= 0x7FFF) && (D->Phase < 0xBFFF)){
        D->ptr += (D->Phase - 0x7FFF);                                          // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->I = *(D->ptr) * -1;                                                  // Получаем значение новой мгновенной амплитуды 
      }
      //------------------------------------------------------------------------ IV
      if (D->Phase >= 0xBFFF) {
        D->ptr += 0x3FFF - (D->Phase - 0xBFFF);                                 // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->I = *(D->ptr) * -1;                                                  // Получаем значение новой мгновенной амплитуды 
      }  
      
      //########################################################################
      D->PhaseQ = D->Phase + (16384);                                           // Доворачиваем основной накопитель фазы на 90 градусов
      D->PhaseQ &= 0xFFFF;                                                      // Усекаем фазовый аккумулятор до 16 бит
      D->ptr = Sin_q16_table;                                                   // Получаем адрес начала таблицы синуса
      
      //------------------------------------------------------------------------ I
      if (D->PhaseQ < 0x3FFF) {
        D->ptr += D->PhaseQ;                                                    // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->Q = *(D->ptr);                                                       // Получаем значение новой мгновенной амплитуды 
      }
      //------------------------------------------------------------------------ II
      if ((D->PhaseQ >= 0x3FFF) && (D->PhaseQ < 0x7FFF)){
        D->ptr += 0x3FFF - (D->PhaseQ - 0x3FFF);                                 // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->Q = *(D->ptr);                                                       // Получаем значение новой мгновенной амплитуды 
      }
      //------------------------------------------------------------------------ III
      if ((D->PhaseQ >= 0x7FFF) && (D->PhaseQ < 0xBFFF)){
        D->ptr += (D->PhaseQ - 0x7FFF);                                          // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->Q = *(D->ptr) * -1;                                                  // Получаем значение новой мгновенной амплитуды 
      }
      //------------------------------------------------------------------------ IV
      if (D->PhaseQ >= 0xBFFF) {
        D->ptr += 0x3FFF - (D->PhaseQ - 0xBFFF);                                // Получаем адрес новой мгновенной амплитуды в таблице синуса
        D->Q = *(D->ptr) * -1;                                                  // Получаем значение новой мгновенной амплитуды 
      }  
      
                                                                  
}
//******************************************************************************
// ENF OF FILE
//******************************************************************************