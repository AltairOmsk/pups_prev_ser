//******************************************************************************
// Секция include: здесь подключается заголовочный файл к модулю
//******************************************************************************
#include "select.h" // Включаем файл заголовка для нашего модуля
//******************************************************************************
// Секция определения переменных, используемых в модуле
//******************************************************************************
//------------------------------------------------------------------------------
// Глобальные
//------------------------------------------------------------------------------
//char GlobalVar1;
//char GlobalVar2;
//...
//------------------------------------------------------------------------------
// Локальные
//------------------------------------------------------------------------------
static DDS16_t  Gen;                                                            // Генератор тона для передачи
static DDS16_t  Gen_RX_M;                                                       // Генераторы тона MARK и SPACE для приема
static DDS16_t  Gen_RX_S;
static SQL_RX_t SqR;
//******************************************************************************
// Секция прототипов локальных функций
//******************************************************************************
//void local_func1 (void);
//void local_func2 (void);
//...
//******************************************************************************
// Секция описания функций (сначала глобальных, потом локальных)
//******************************************************************************


//******************************************************************************
//   Сгенерировать сигнал на открытие или закрытие шумоподавителя
//******************************************************************************
/*
Вызывается с частотой 8.138 кГц
Если нет указания какой сигнал генерировать - просто возвращаем входной сигнал без изменений
Генерируем НЧ тоновый сигнал, который замещает собой сигнал с микрофона
*/
float create_TX_SQL_signal   (uint16_t *Type, uint16_t Scale, float In){
static uint16_t Signal=0;                                                       // Передаваемое сообщение
static uint16_t BitTick=0;                                                      // Длительность бита в тиках
static uint16_t BitCnt=0;                                                       // Номер текущего передаваемого бита
  
  if ((*Type) == 0)             return In;                                      // Генерация запрещена, просто повторяем входной сигнал

  if ((BitTick == 0) && (BitCnt == 0)) {                                        // Запуск генерации нового сигнала
    Signal  = *Type;
    BitTick = 0;
    BitCnt  = 0;
  }
  
  
  if (++BitTick >= SAMPLE_LEN_TICK) {  BitTick = 0;                             // Перебор битов в сигнале
    if (++BitCnt > SIGNAL_LEN_BIT) goto END_SIGNAL;                             // Переводим бит с контролем максимальной длины
  }
  
  

  
  if (Signal & (1<<BitCnt)) {                                                   // Определяем частоту генерируемого сигнала
    Gen.Freq = MARK_TONE;                                                       // В зависимости от текущего бита
  } else {
    Gen.Freq = SPACE_TONE;
  }
  
  
  

  
  Gen.Fdiskr = SAMPLE_RATE;
  dds16(&Gen);                                                                  // Формируем тон
  return Gen.I * Scale;                                                         // И выдаем его в масштабированном виде

  
//------------------------------------------------------------------------------
END_SIGNAL:                                                                     // Сигнал окончен, готовимся к передаче нового бита
  *Type = 0;
  Signal = 0;
  BitTick = 0;
  BitCnt = 0;
  return 0;
}                                





//******************************************************************************
// Выбираем канал в котором лучше сигнал шум
//******************************************************************************
/*
Умножаем каждый канал на SIN и COS MARR и SPACE Гц, получаем 8 чисел
Получаем модули частот на каждом канале - это 4 числа
Сравниваем модули частот для двух каналов, получаем 2 битовых потока
Каждый битовый поток сравниваем с образцами открывающей и закрывающей последовательности

Если в каком то канале есть активная последовательность - обновляем!! на выходе номер канала
Если нет признков приема ожидаемого сигнала ничего не делаем

*/
uint8_t  select_RX_channel (float MA_Ch, float GA_Ch){

  Gen_RX_M.Fdiskr = SAMPLE_RATE;
  Gen_RX_S.Fdiskr = SAMPLE_RATE;
  dds16(&Gen_RX_M);                                                             // Генерируем отсчеты образцовых генераторов
  dds16(&Gen_RX_S);
  
  SqR.MA_M_I = Gen_RX_M.I * MA_Ch;                                              // Перемножение входного сигнала от МА и ГА
  SqR.MA_M_Q = Gen_RX_M.Q * MA_Ch;                                              // на частоты искомого сигнала
  SqR.MA_S_I = Gen_RX_M.I * MA_Ch;
  SqR.MA_S_Q = Gen_RX_M.Q * MA_Ch;
  
  SqR.GA_M_I = Gen_RX_M.I * GA_Ch;                                              // Для ГА антенны
  SqR.GA_M_Q = Gen_RX_M.Q * GA_Ch;
  SqR.GA_S_I = Gen_RX_M.I * GA_Ch;
  SqR.GA_S_Q = Gen_RX_M.Q * GA_Ch;
  
  SqR.MA_M   = (SqR.MA_M_I * SqR.MA_M_I) + (SqR.MA_M_Q * SqR.MA_M_Q);           // Получение уровня MARK и SPACE для магнитнго канала
  SqR.MA_S   = (SqR.MA_S_I * SqR.MA_S_I) + (SqR.MA_S_Q * SqR.MA_S_Q);
  
  SqR.GA_M   = (SqR.GA_M_I * SqR.GA_M_I) + (SqR.GA_M_Q * SqR.GA_M_Q);           // Получение уровня MARK и SPACE для ГА канала
  SqR.GA_S   = (SqR.GA_S_I * SqR.GA_S_I) + (SqR.GA_S_Q * SqR.GA_S_Q);
  
  
  
  
  
  return 0;
}   






//******************************************************************************
// ENF OF FILE
//******************************************************************************