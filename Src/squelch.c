//******************************************************************************
// Секция include: здесь подключается заголовочный файл к модулю
//******************************************************************************
#include "squelch.h" // Включаем файл заголовка для нашего модуля
//******************************************************************************
// Секция определения переменных, используемых в модуле
//******************************************************************************
//------------------------------------------------------------------------------
// Глобальные
//------------------------------------------------------------------------------
//char GlobalVar1;
//char GlobalVar2;
//...
//------------------------------------------------------------------------------
// Локальные
//------------------------------------------------------------------------------
//static char LocalVar1;
//static char LocalVar2;
//...
//******************************************************************************
// Секция прототипов локальных функций
//******************************************************************************
static float   fir32 (float *In, float *Coeff);                                 // FIR filetr 32 tap
static void    shift_buf_32 (float *In);                                        // Shift back buff 32 
static void    shift_buf_40 (float *In);                                        // Shift back buff 40
static void    vector32_mul (float *In, float *Out, float *Const);              // Умножить поэлементно вектор на число
static void    vector32_add (float *In, float *Add);                            // Прибавить поэлементно к вектору In вектор Add  
static float   vector32_squadd (float *In);                                     // Оквадратить массив и сложить все элементы

//******************************************************************************
// Секция описания функций (сначала глобальных, потом локальных)
//******************************************************************************


//******************************************************************************
//   Стартовая инициализация коэффициентов
//******************************************************************************
void  squelch_init      (SQUELCH_t *S){
  S->Out        = 0;
  S->Tmp_f      = 0;
  S->Mu         = 0.01;
  S->Leakage    = 0.99;
  
  for (uint8_t i=0;i<32;i++){
    *(S->Coeff + i) = 0;
    *(S->Tmp_buf + i) = 0;
  }
  
  for (uint8_t i=0;i<40;i++){
    *(S->In_buf + i) = 0;
  }
  
}


float gena (void){
static uint8_t Tick=0;
  
  if (++Tick == 8) {
    Tick = 0;
  }
  
  if (Tick < 4) return -0.5;
  else return 0.5;
  
  return 8;
}


//******************************************************************************
//   LMS фильтр - шумоподавитель
//******************************************************************************
float squelch (float In, SQUELCH_t *S){
  
  if (S->Enable == 0) return In;                                                // Повторитель, если не включено

  if (In > 9900) In = 9900;
  
  if (In < -9900) In = - 9900;
  
  
  *(S->In_buf+39) = In/10000;                                                         // Получаем новый отсчет
  //*(S->In_buf+39) = gena();
  //*(S->In_buf+39) = 0;
  
  S->Out = fir32((S->In_buf+8), S->Coeff);                                      // Применяем основной фильтр
  
  S->Tmp_f = *(S->In_buf) - S->Out;                                             // Инвертированный выходной сигнал суммируем с задержанным входным
  
  S->Tmp_f *= S->Mu;                                                            // Применям Mu к сигналу ошибки
  
  vector32_mul ((S->In_buf+8), S->Tmp_buf, &(S->Tmp_f));                        // Умножаем входной вектор на сигнал ошибки. Результат в Tmp_buf        
  
  vector32_add (S->Tmp_buf, S->Coeff);                                          // Складываем предидущие коэффициенты с новыми. Результат в Tmp_buf
  
  vector32_mul (S->Tmp_buf, S->Coeff, &S->Leakage);                             // Формируем новый набор коэффициентов. Результат в Coeff
  
  
  //---   Подготовка к новому циклу   ------------------------------------------
  shift_buf_40(S->In_buf);                                                      // Освобождаем место в буфере под новый отсчет
  return S->Out*100000;
}






//******************************************************************************
//   NLMS фильтр - шумоподавитель
//******************************************************************************
float squelch_N (float In, SQUELCH_t *S){ 
  
  if (S->Enable == 0) return In;                                                // Повторитель, если не включено

  *(S->In_buf+39) = In;                                                       // Получаем новый отсчет
  
 // *(S->In_buf+39) = 2;
  
  S->Out = fir32((S->In_buf+8), S->Coeff);                                      // Применяем основной фильтр
  
  S->Tmp_f = *(S->In_buf) - S->Out;                                             // Инвертированный выходной сигнал суммируем с задержанным входным
  
  S->Tmp_f *= S->Mu;                                                            // Применям Mu к сигналу ошибки
  
  S->Tmp_f /= (vector32_squadd (S->In_buf+8) + 0.00001);
  
  vector32_mul ((S->In_buf+8), S->Tmp_buf, &(S->Tmp_f));                        // Умножаем входной вектор на сигнал ошибки. Результат в Tmp_buf        
  
  vector32_add (S->Tmp_buf, S->Coeff);                                          // Складываем предидущие коэффициенты с новыми. Результат в Tmp_buf
  
  vector32_mul (S->Tmp_buf, S->Coeff, &S->Leakage);                             // Формируем новый набор коэффициентов. Результат в Coeff
  
  
  //---   Подготовка к новому циклу   ------------------------------------------
  shift_buf_40(S->In_buf);                                                      // Освобождаем место в буфере под новый отсчет
  return S->Out*10;
}














//******************************************************************************
// FIR Filter 32 tap
//******************************************************************************
static float fir32 (float *In, float *Coeff){
  float out1 = 0;
  
  
//  out1 += *(In +  0) * *(Coeff + 31);
//  out1 += *(In +  1) * *(Coeff + 30);
//  out1 += *(In +  2) * *(Coeff + 29);
//  out1 += *(In +  3) * *(Coeff + 28);
//  out1 += *(In +  4) * *(Coeff + 27);
//  out1 += *(In +  5) * *(Coeff + 26);
//  out1 += *(In +  6) * *(Coeff + 25);
//  out1 += *(In +  7) * *(Coeff + 24);
//  out1 += *(In +  8) * *(Coeff + 23);
//  out1 += *(In +  9) * *(Coeff + 22);
//  out1 += *(In + 10) * *(Coeff + 21);
//  
//  out1 += *(In + 11) * *(Coeff + 20);
//  out1 += *(In + 12) * *(Coeff + 19);
//  out1 += *(In + 13) * *(Coeff + 18);
//  out1 += *(In + 14) * *(Coeff + 17);
//  out1 += *(In + 15) * *(Coeff + 16);
//  out1 += *(In + 16) * *(Coeff + 15);
//  out1 += *(In + 17) * *(Coeff + 14);
//  out1 += *(In + 18) * *(Coeff + 13);
//  out1 += *(In + 19) * *(Coeff + 12);
//  out1 += *(In + 20) * *(Coeff + 11);
//  
//  out1 += *(In + 21) * *(Coeff + 10);
//  out1 += *(In + 22) * *(Coeff +  9);
//  out1 += *(In + 23) * *(Coeff +  8);
//  out1 += *(In + 24) * *(Coeff +  7);
//  out1 += *(In + 25) * *(Coeff +  6);
//  out1 += *(In + 26) * *(Coeff +  5);
//  out1 += *(In + 27) * *(Coeff +  4);
//  out1 += *(In + 28) * *(Coeff +  3);
//  out1 += *(In + 29) * *(Coeff +  2);
//  out1 += *(In + 30) * *(Coeff +  1);
//  out1 += *(In + 31) * *(Coeff +  0);
  
  
  
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++); // 16
  
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++);
  out1 += (*In++) * (*Coeff++); // 32

  return out1; 
}



//******************************************************************************
// Сдвиг буфера размером 32 на 1 элемент назад
//******************************************************************************
static void shift_buf_32 (float *In) {
  *(In +	0	) = *(In + 	1	);
  *(In +	1	) = *(In + 	2	);
  *(In +	2	) = *(In + 	3	);
  *(In +	3	) = *(In + 	4	);
  *(In +	4	) = *(In + 	5	);
  *(In +	5	) = *(In + 	6	);
  *(In +	6	) = *(In + 	7	);
  *(In +	7	) = *(In + 	8	);
  *(In +	8	) = *(In + 	9	);
  *(In +	9	) = *(In + 	10	);
  *(In +	10	) = *(In + 	11	);
  *(In +	11	) = *(In + 	12	);
  *(In +	12	) = *(In + 	13	);
  *(In +	13	) = *(In + 	14	);
  *(In +	14	) = *(In + 	15	);
  *(In +	15	) = *(In + 	16	);
  *(In +	16	) = *(In + 	17	);
  *(In +	17	) = *(In + 	18	);
  *(In +	18	) = *(In + 	19	);
  *(In +	19	) = *(In + 	20	);
  *(In +	20	) = *(In + 	21	);
  *(In +	21	) = *(In + 	22	);
  *(In +	22	) = *(In + 	23	);
  *(In +	23	) = *(In + 	24	);
  *(In +	24	) = *(In + 	25	);
  *(In +	25	) = *(In + 	26	);
  *(In +	26	) = *(In + 	27	);
  *(In +	27	) = *(In + 	28	);
  *(In +	28	) = *(In + 	29	);
  *(In +	29	) = *(In + 	30	);
  *(In +	30	) = *(In + 	31	);
  
}



//******************************************************************************
// Сдвиг буфера размером 40 на 1 элемент назад
//******************************************************************************
static void shift_buf_40 (float *In) {
  *(In +	0	) = *(In + 	1	);
  *(In +	1	) = *(In + 	2	);
  *(In +	2	) = *(In + 	3	);
  *(In +	3	) = *(In + 	4	);
  *(In +	4	) = *(In + 	5	);
  *(In +	5	) = *(In + 	6	);
  *(In +	6	) = *(In + 	7	);
  *(In +	7	) = *(In + 	8	);
  *(In +	8	) = *(In + 	9	);
  *(In +	9	) = *(In + 	10	);
  *(In +	10	) = *(In + 	11	);
  *(In +	11	) = *(In + 	12	);
  *(In +	12	) = *(In + 	13	);
  *(In +	13	) = *(In + 	14	);
  *(In +	14	) = *(In + 	15	);
  *(In +	15	) = *(In + 	16	);
  *(In +	16	) = *(In + 	17	);
  *(In +	17	) = *(In + 	18	);
  *(In +	18	) = *(In + 	19	);
  *(In +	19	) = *(In + 	20	);
  *(In +	20	) = *(In + 	21	);
  *(In +	21	) = *(In + 	22	);
  *(In +	22	) = *(In + 	23	);
  *(In +	23	) = *(In + 	24	);
  *(In +	24	) = *(In + 	25	);
  *(In +	25	) = *(In + 	26	);
  *(In +	26	) = *(In + 	27	);
  *(In +	27	) = *(In + 	28	);
  *(In +	28	) = *(In + 	29	);
  *(In +	29	) = *(In + 	30	);
  *(In +	30	) = *(In + 	31	);
  *(In +	31	) = *(In + 	32	);
  *(In +	32	) = *(In + 	33	);
  *(In +	33	) = *(In + 	34	);
  *(In +	34	) = *(In + 	35	);
  *(In +	35	) = *(In + 	36	);
  *(In +	36	) = *(In + 	37	);
  *(In +	37	) = *(In + 	38	);
  *(In +	38	) = *(In + 	39	);
  
}





//******************************************************************************
//   Умножить поэлементно вектор на число
//******************************************************************************
static void    vector32_mul (float *In, float *Out, float *Const){
  *(Out +  0) = *(In +  0) * *Const;
  *(Out +  1) = *(In +  1) * *Const;
  *(Out +  2) = *(In +  2) * *Const;
  *(Out +  3) = *(In +  3) * *Const;
  *(Out +  4) = *(In +  4) * *Const;
  *(Out +  5) = *(In +  5) * *Const;
  *(Out +  6) = *(In +  6) * *Const;
  *(Out +  7) = *(In +  7) * *Const;
  *(Out +  8) = *(In +  8) * *Const;
  *(Out +  9) = *(In +  9) * *Const;
  
  *(Out + 10) = *(In + 10) * *Const;
  *(Out + 11) = *(In + 11) * *Const;
  *(Out + 12) = *(In + 12) * *Const;
  *(Out + 13) = *(In + 13) * *Const;
  *(Out + 14) = *(In + 14) * *Const;
  *(Out + 15) = *(In + 15) * *Const;
  *(Out + 16) = *(In + 16) * *Const;
  *(Out + 17) = *(In + 17) * *Const;
  *(Out + 18) = *(In + 18) * *Const;
  *(Out + 19) = *(In + 19) * *Const;
  
  *(Out + 20) = *(In + 20) * *Const;
  *(Out + 21) = *(In + 21) * *Const;
  *(Out + 22) = *(In + 22) * *Const;
  *(Out + 23) = *(In + 23) * *Const;
  *(Out + 24) = *(In + 24) * *Const;
  *(Out + 25) = *(In + 25) * *Const;
  *(Out + 26) = *(In + 26) * *Const;
  *(Out + 27) = *(In + 27) * *Const;
  *(Out + 28) = *(In + 28) * *Const;
  *(Out + 29) = *(In + 29) * *Const;
  
  *(Out + 30) = *(In + 30) * *Const;
  *(Out + 31) = *(In + 31) * *Const;
  
}              




//******************************************************************************
//   Прибавить поэлементно к вектору In вектор Add 
//******************************************************************************
static void    vector32_add (float *In, float *Add){
  *(In +  0) += *(Add +  0);
  *(In +  1) += *(Add +  1);
  *(In +  2) += *(Add +  2);
  *(In +  3) += *(Add +  3);
  *(In +  4) += *(Add +  4);
  *(In +  5) += *(Add +  5);
  *(In +  6) += *(Add +  6);
  *(In +  7) += *(Add +  7);
  *(In +  8) += *(Add +  8);
  *(In +  9) += *(Add +  9);
  
  *(In + 10) += *(Add + 10);
  *(In + 11) += *(Add + 11);
  *(In + 12) += *(Add + 12);
  *(In + 13) += *(Add + 13);
  *(In + 14) += *(Add + 14);
  *(In + 15) += *(Add + 15);
  *(In + 16) += *(Add + 16);
  *(In + 17) += *(Add + 17);
  *(In + 18) += *(Add + 18);
  *(In + 19) += *(Add + 19);
  
  *(In + 20) += *(Add + 20);
  *(In + 21) += *(Add + 21);
  *(In + 22) += *(Add + 22);
  *(In + 23) += *(Add + 23);
  *(In + 24) += *(Add + 24);
  *(In + 25) += *(Add + 25);
  *(In + 26) += *(Add + 26);
  *(In + 27) += *(Add + 27);
  *(In + 28) += *(Add + 28);
  *(In + 29) += *(Add + 29);
  
  *(In + 30) += *(Add + 30);
  *(In + 31) += *(Add + 31);
}                            



//******************************************************************************
//   Оквадратить массив и сложить все элементы
//******************************************************************************
static float   vector32_squadd (float *In){
float Out=0;


    Out += *(In + 0) * *(In + 0);
    Out += *(In + 1) * *(In + 1);
    Out += *(In + 2) * *(In + 2);
    Out += *(In + 3) * *(In + 3);
    Out += *(In + 4) * *(In + 4);
    Out += *(In + 5) * *(In + 5);
    Out += *(In + 6) * *(In + 6);
    Out += *(In + 7) * *(In + 7);
    Out += *(In + 8) * *(In + 8);
    Out += *(In + 9) * *(In + 9);
    
    Out += *(In + 10) * *(In + 10);
    Out += *(In + 11) * *(In + 11);
    Out += *(In + 12) * *(In + 12);
    Out += *(In + 13) * *(In + 13);
    Out += *(In + 14) * *(In + 14);
    Out += *(In + 15) * *(In + 15);
    Out += *(In + 16) * *(In + 16);
    Out += *(In + 17) * *(In + 17);
    Out += *(In + 18) * *(In + 18);
    Out += *(In + 19) * *(In + 19);
    
    Out += *(In + 20) * *(In + 20);
    Out += *(In + 21) * *(In + 21);
    Out += *(In + 22) * *(In + 22);
    Out += *(In + 23) * *(In + 23);
    Out += *(In + 24) * *(In + 24);
    Out += *(In + 25) * *(In + 25);
    Out += *(In + 26) * *(In + 26);
    Out += *(In + 27) * *(In + 27);
    Out += *(In + 28) * *(In + 28);
    Out += *(In + 29) * *(In + 29);
    
    Out += *(In + 30) * *(In + 30);
    Out += *(In + 31) * *(In + 31);


//  Out += pow(*(In + 0), 2);  
//  Out += pow(*(In + 1), 2);
//  Out += pow(*(In + 2), 2);
//  Out += pow(*(In + 3), 2);
//  Out += pow(*(In + 4), 2);
//  Out += pow(*(In + 5), 2);
//  Out += pow(*(In + 6), 2);
//  Out += pow(*(In + 7), 2);
//  Out += pow(*(In + 8), 2);
//  Out += pow(*(In + 9), 2);
//  
//  Out += pow(*(In + 10), 2);  
//  Out += pow(*(In + 11), 2);
//  Out += pow(*(In + 12), 2);
//  Out += pow(*(In + 13), 2);
//  Out += pow(*(In + 14), 2);
//  Out += pow(*(In + 15), 2);
//  Out += pow(*(In + 16), 2);
//  Out += pow(*(In + 17), 2);
//  Out += pow(*(In + 18), 2);
//  Out += pow(*(In + 19), 2);
//  
//  Out += pow(*(In + 20), 2);  
//  Out += pow(*(In + 21), 2);
//  Out += pow(*(In + 22), 2);
//  Out += pow(*(In + 23), 2);
//  Out += pow(*(In + 24), 2);
//  Out += pow(*(In + 25), 2);
//  Out += pow(*(In + 26), 2);
//  Out += pow(*(In + 27), 2);
//  Out += pow(*(In + 28), 2);
//  Out += pow(*(In + 29), 2);
//  
//  Out += pow(*(In + 30), 2);  
//  Out += pow(*(In + 31), 2);
  
  
  return Out;
}                                     

//******************************************************************************
// ENF OF FILE
//******************************************************************************