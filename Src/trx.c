/*
* Copyright (C) 2018 Yuri Ryzhenko <Y.Ryzhenko@hi-tech.org>, Aleksey Kirsanov <a.kirsanov@iva-tech.ru>
* All rights reserved
*
* File Name  : trx.c
* Description: DSP processing
*/
//******************************************************************************
// Секция include: здесь подключается заголовочный файл к модулю
//******************************************************************************
#include "trx.h" // Включаем файл заголовка для нашего модуля
/*

---   RX   ---
В режиме приема движение программы задается прерываниями по заполнению приемного буфера АЦП кодека.
Каждое прерывание в буфере лежит 48 отсчетов с частотой дискретизации 48828,125 Гц. (50МГц/1024)

Каждый сэмпл нужно прпустить через ФВЧ для удаления постоянной составляющей,
перемножить на I и Q DDS.
С этого момента работа идет в два потока. 
Каждый поток пропускается последовательно через два КИХ фильтра.

Сначала децимируем на 4 до 12 кГц, затем, на fдискр 12 кГц делаем 
еще одну фильтрацию до выходной полосы 3 кГц.

Последний ФНЧ - "поворачивающий". Все коэффициенты умножены на последовательность 
0,1,0,-1 сдвинутую на 90* для второго фильтра

Выход поворачивающих фильтров складывается.

Результат линейно интерполируется в 4 раза и подается на ЦАП.


---   TX   ---
Движение программы задается прерыванием 8 кГц от таймера 5.
При запуске таймера 5, нужно одновременно стартовать таймер 1.

Каждое прерывание 8кГц, получаем отсчет АЦП.
Складываем все в буфер общей длиной 96 отсчетов.
При получении 48 отсчетов, умножаем их на последовательность 010-1,
результат поскаем в два фильтра.


*/
//******************************************************************************
// Секция определения переменных, используемых в модуле
//******************************************************************************
//------------------------------------------------------------------------------
// Глобальные
//------------------------------------------------------------------------------
CC_CH_SET_t PWM_TX;                                                             // Значения 4 каналов СС для таймера1, который делает ШИМ передатчика
//------------------------------------------------------------------------------
// Локальные
//------------------------------------------------------------------------------
static float   RX_I_buf_src [128];
static float   RX_Q_buf_src [128];
static float   RX_out_buf_src [128];
static float TmpI, TmpQ;

static float TmpI, TmpQ;

static float LPF128_coeff_FOS[128] = {
  -0.0005792740267,-0.001527770655,-0.001558088697,0.0002034751669, 0.002186335623,
   0.001971224789,7.854278374e-05,-0.0004196400405, 0.001140304026,  0.00172246201,
  -4.219804759e-05,-0.001067468082,0.0006658853963, 0.001953125931,3.720523819e-05,
  -0.001768488088,0.0001469741983, 0.002414081013,0.0004332866229,-0.002469512401,
  -0.0005766084068, 0.002960580867, 0.001177774277, -0.00311471452,-0.001587804523,
   0.003486063099, 0.002301526954,-0.003641266841,-0.002964248648, 0.003875480965,
   0.003846931038,-0.003946620971,-0.004762347788, 0.004003732931, 0.005860865582,
  -0.003904954065,-0.007047416642, 0.003717049723, 0.008410990238,-0.003347147955,
  -0.009912017733, 0.002810403472,  0.01161649544,-0.002027083188, -0.01352725364,
  0.0009685717523,  0.01572340727,0.0004677910474, -0.01827319898,-0.002389951609,
    0.02133014798, 0.005005199928,  -0.0251331199,-0.008652979508,  0.03014849685,
    0.01400371641, -0.03734041005, -0.02254408598,  0.04909706488,  0.03841046616,
   -0.07328449935, -0.07897875458,   0.1597828418,   0.4397341907,   0.4397341907,
     0.1597828418, -0.07897875458, -0.07328449935,  0.03841046616,  0.04909706488,
   -0.02254408598, -0.03734041005,  0.01400371641,  0.03014849685,-0.008652979508,
    -0.0251331199, 0.005005199928,  0.02133014798,-0.002389951609, -0.01827319898,
  0.0004677910474,  0.01572340727,0.0009685717523, -0.01352725364,-0.002027083188,
    0.01161649544, 0.002810403472,-0.009912017733,-0.003347147955, 0.008410990238,
   0.003717049723,-0.007047416642,-0.003904954065, 0.005860865582, 0.004003732931,
  -0.004762347788,-0.003946620971, 0.003846931038, 0.003875480965,-0.002964248648,
  -0.003641266841, 0.002301526954, 0.003486063099,-0.001587804523, -0.00311471452,
   0.001177774277, 0.002960580867,-0.0005766084068,-0.002469512401,0.0004332866229,
   0.002414081013,0.0001469741983,-0.001768488088,3.720523819e-05, 0.001953125931,
  0.0006658853963,-0.001067468082,-4.219804759e-05,  0.00172246201, 0.001140304026,
  -0.0004196400405,7.854278374e-05, 0.001971224789, 0.002186335623,0.0002034751669,
  -0.001558088697,-0.001527770655,-0.0005792740267
};



static float LPF128_coeff_I[128] = {
0.000689452, 0, -0.001085518, 0, -0.000834976, 0, -0.000867653, 0, -0.000939936, 0, -0.000951374, 0, -0.000872746, 
0, -0.000655371, 0, -0.000293313, 0, 0.000238648, 0, 0.000921106, 0, 0.001747734, 0, 0.002665727, 0, 0.003631127, 
0, 0.004556727, 0, 0.005364822, 0, 0.005942747, 0, 0.006193872, 0, 0.005998971, 0, 0.005262728, 0, 0.003878474, 0, 
0.00177462, 0, -0.001133643, 0, -0.004894235, 0, -0.009573925, 0, -0.015253574, 0, -0.022096759, 0, -0.030448133, 0,
-0.041144352, 0, -0.056423068, 0, -0.084002204, 0, -0.173610658, 0, 0.423209667, 0, 0.06028926, 0, 0.01817348, 0,
0.001434684, 0, -0.007280783, 0, -0.012124674, 0, -0.014629164, 0, -0.015543104, 0, -0.015308749, 0, -0.014250725,
0, -0.012613762, 0, -0.010615665, 0, -0.008439539, 0, -0.006244404, 0, -0.004152585, 0, -0.002272794, 0, -0.000665878, 
0, 0.000615057, 0, 0.001565725, 0, 0.002182567, 0, 0.002505872, 0, 0.002565679, 0, 0.002428175, 0, 0.002136075, 0,
0.001760851, 0, 0.001339775, 0, 0.000933749, 0, 0.000562865, 0, 0.000268996, 0, 4.50008E-05, 0, -0.000143248, 0, -0.001359881, 0
};



static float LPF128_coeff_Q[128] = {
0, 0.001359881, 0, 0.000143248, 0, -4.50008E-05, 0, -0.000268996, 0, -0.000562865, 0, -0.000933749, 0, -0.001339775, 
0, -0.001760851, 0, -0.002136075, 0, -0.002428175, 0, -0.002565679, 0, -0.002505872, 0, -0.002182567, 0, -0.001565725, 
0, -0.000615057, 0, 0.000665878, 0, 0.002272794, 0, 0.004152585, 0, 0.006244404, 0, 0.008439539, 0, 0.010615665, 0, 
0.012613762, 0, 0.014250725, 0, 0.015308749, 0, 0.015543104, 0, 0.014629164, 0, 0.012124674, 0, 0.007280783, 0, -0.001434684, 
0, -0.01817348, 0, -0.06028926, 0, -0.423209667, 0, 0.173610658, 0, 0.084002204, 0, 0.056423068, 0, 0.041144352, 
0, 0.030448133, 0, 0.022096759, 0, 0.015253574, 0, 0.009573925, 0, 0.004894235, 0, 0.001133643, 0, -0.00177462, 0, 
-0.003878474, 0, -0.005262728, 0, -0.005998971, 0, -0.006193872, 0, -0.005942747, 0, -0.005364822, 0, -0.004556727, 
0, -0.003631127, 0, -0.002665727, 0, -0.001747734, 0, -0.000921106, 0, -0.000238648, 0, 0.000293313, 0, 0.000655371, 
0, 0.000872746, 0, 0.000951374, 0, 0.000939936, 0, 0.000867653, 0, 0.000834976, 0, 0.001085518, 0, -0.000689452
};


static float LPF72_coeff_I[72] = {
-0.000299496, 0, 0.006251109, 0, -0.00088417, 0, -0.001752382, 0, -0.002545445, 0, -0.003677944, 0, -0.005157094, 0, 
-0.007020499, 0, -0.009261774, 0, -0.011926482, 0, -0.015098017, 0, -0.018879011, 0, -0.023492899, 0, -0.029374287, 0, 
-0.037458751, 0, -0.050108943, 0, -0.075152241, 0, -0.162435338, 0, 0.436390072, 0, 0.075068064, 0, 0.034070447, 0, 
0.017930722, 0, 0.009282117, 0, 0.003980233, 0, 0.000534344, 0, -0.001734345, 0, -0.003187171, 0, -0.004034869, 0, 
-0.004447886, 0, -0.004535474, 0, -0.004379507, 0, -0.004118969, 0, -0.003898475, 0, -0.004164208, 0, -0.00637604, 0, 
0.002727727, 0
};


static float LPF72_coeff_Q[72] = {
0, -0.002727727, 0, 0.00637604, 0, 0.004164208, 0, 0.003898475, 0, 0.004118969, 0, 0.004379507, 0, 0.004535474, 0, 
0.004447886, 0, 0.004034869, 0, 0.003187171, 0, 0.001734345, 0, -0.000534344, 0, -0.003980233, 0, -0.009282117, 0, 
-0.017930722, 0, -0.034070447, 0, -0.075068064, 0, -0.436390072, 0, 0.162435338, 0, 0.075152241, 0, 0.050108943, 0, 
0.037458751, 0, 0.029374287, 0, 0.023492899, 0, 0.018879011, 0, 0.015098017, 0, 0.011926482, 0, 0.009261774, 0, 
0.007020499, 0, 0.005157094, 0, 0.003677944, 0, 0.002545445, 0, 0.001752382, 0, 0.00088417, 0, -0.006251109, 0, 
0.000299496
};



static float LPF72_coeff_BPF[72] = {
    0.01816402748,  0.01522029843, -0.03038432822, -0.02277860418, 0.002668412635,
   -0.01652778126,-0.0004839503672, 0.003607358551,-0.008412276395,  0.01391428802,
  -0.0003488566144, 0.005689756945,  0.01852007583,-0.002305509523,  0.02206846327,
    0.01017898042, 0.004214486573,  0.02750832587,-0.005713096354,  0.01660396159,
    0.01013183128, -0.01606196165,  0.02022934891, -0.02646276355, -0.01168485265,
  -0.003473412711, -0.05967692658,0.0001118928776, -0.05962351337, -0.05884743109,
  -0.006959787104,  -0.1294771135, 0.004390747286,   -0.085454382,  -0.1781792194,
     0.5290910006,   0.5290910006,  -0.1781792194,   -0.085454382, 0.004390747286,
    -0.1294771135,-0.006959787104, -0.05884743109, -0.05962351337,0.0001118928776,
   -0.05967692658,-0.003473412711, -0.01168485265, -0.02646276355,  0.02022934891,
   -0.01606196165,  0.01013183128,  0.01660396159,-0.005713096354,  0.02750832587,
   0.004214486573,  0.01017898042,  0.02206846327,-0.002305509523,  0.01852007583,
   0.005689756945,-0.0003488566144,  0.01391428802,-0.008412276395, 0.003607358551,
  -0.0004839503672, -0.01652778126, 0.002668412635, -0.02277860418, -0.03038432822,
    0.01522029843,  0.01816402748
};


static float LPF128_coeff_BPF[128] = {
    -0.0015939445,-0.002026672708,0.0009899049764, 0.001004188904,-0.0008363336092, // плоский
  0.0007978432113,0.0001228493493,-0.0006895974511, 0.001431546756,-3.431979712e-05,
  0.0004910127027,  0.00250961748,0.0001341611787, 0.002122434787, 0.002757218666,
  -0.0001990952587, 0.003007777268, 0.001095696236,-0.001259400044, 0.002470859326,
  -0.002297520405,-0.002306511858,0.0006326888106,-0.006051237695,-0.002315688878,
  -0.001980979694,-0.008346012793,-0.0008046311559,-0.004668188281,-0.007571298629,
   0.001929494319,-0.006413627882,-0.002806493081, 0.005005664192, -0.00595109351,
   0.005561997648, 0.007142901421,-0.002391742542,  0.01523478236, 0.006840893999,
   0.003955265507,  0.02207957953, 0.002896479098,  0.01123944577,  0.02127549239,
  -0.004805081524,  0.01644718088,  0.00924612768, -0.01458882727,   0.0162019413,
   -0.01466590259, -0.02297371812, 0.007518339437, -0.04739281163,   -0.025043929,
   -0.01210221276, -0.08264300972, -0.01394832507,  -0.0471066609,  -0.1124743596,
    0.02845418267,   -0.127569899,  -0.1295776516,   0.5149127841,   0.5149127841,
    -0.1295776516,   -0.127569899,  0.02845418267,  -0.1124743596,  -0.0471066609,
   -0.01394832507, -0.08264300972, -0.01210221276,   -0.025043929, -0.04739281163,
   0.007518339437, -0.02297371812, -0.01466590259,   0.0162019413, -0.01458882727,
    0.00924612768,  0.01644718088,-0.004805081524,  0.02127549239,  0.01123944577,
   0.002896479098,  0.02207957953, 0.003955265507, 0.006840893999,  0.01523478236,
  -0.002391742542, 0.007142901421, 0.005561997648, -0.00595109351, 0.005005664192,
  -0.002806493081,-0.006413627882, 0.001929494319,-0.007571298629,-0.004668188281,
  -0.0008046311559,-0.008346012793,-0.001980979694,-0.002315688878,-0.006051237695,
  0.0006326888106,-0.002306511858,-0.002297520405, 0.002470859326,-0.001259400044,
   0.001095696236, 0.003007777268,-0.0001990952587, 0.002757218666, 0.002122434787,
  0.0001341611787,  0.00250961748,0.0004910127027,-3.431979712e-05, 0.001431546756,
  -0.0006895974511,0.0001228493493,0.0007978432113,-0.0008363336092, 0.001004188904,
  0.0009899049764,-0.002026672708,  -0.0015939445




//  0.0009060795419, 0.001384232892,-0.001498154248,-0.001339343144, 0.000137886047,   // С корректором
//  -0.001637737267,-0.0003689618025,-0.0003879847354, -0.00224390626,0.0004025002127,
//  -0.001193920965,-0.001606688951, 0.001042773598,-0.002534785308,-3.541054684e-05,
//   0.001246571192,-0.002611615695, 0.002507860307,-1.77978236e-05,-0.001250783913,
//   0.005156211555,-0.001198972226, 0.002352094045, 0.005540988874,-0.001971469494,
//    0.00755919423, 0.004050708842,-0.0002478903043,  0.01095675677,-5.194489859e-05,
//   0.004852636717,  0.01139036659,  -0.0038010024,  0.01039156783,  0.00538613461,
//  -0.003991045989,  0.01493605971,-0.004911461845,-0.0009693953907,  0.01140971202,
//   -0.01508065592, 0.006972386967,-0.0009776750812, -0.02216745168,  0.01060386095,
//   -0.02034870163, -0.01686351374, 0.006353975739, -0.04391906038,-0.006586837582,
//   -0.01130730752, -0.05235439539, 0.009333194233, -0.04964920133, -0.04941450804,
//    0.01855295897,  -0.0827935338,-0.007988450117, -0.01094134897,  -0.1454017311,
//    0.09694755077,0.0001353927219,  -0.1567170024,   0.4761429727,   0.4761429727,
//    -0.1567170024,0.0001353927219,  0.09694755077,  -0.1454017311, -0.01094134897,
//  -0.007988450117,  -0.0827935338,  0.01855295897, -0.04941450804, -0.04964920133,
//   0.009333194233, -0.05235439539, -0.01130730752,-0.006586837582, -0.04391906038,
//   0.006353975739, -0.01686351374, -0.02034870163,  0.01060386095, -0.02216745168,
//  -0.0009776750812, 0.006972386967, -0.01508065592,  0.01140971202,-0.0009693953907,
//  -0.004911461845,  0.01493605971,-0.003991045989,  0.00538613461,  0.01039156783,
//    -0.0038010024,  0.01139036659, 0.004852636717,-5.194489859e-05,  0.01095675677,
//  -0.0002478903043, 0.004050708842,  0.00755919423,-0.001971469494, 0.005540988874,
//   0.002352094045,-0.001198972226, 0.005156211555,-0.001250783913,-1.77978236e-05,
//   0.002507860307,-0.002611615695, 0.001246571192,-3.541054684e-05,-0.002534785308,
//   0.001042773598,-0.001606688951,-0.001193920965,0.0004025002127, -0.00224390626,
//  -0.0003879847354,-0.0003689618025,-0.001637737267, 0.000137886047,-0.001339343144,
//  -0.001498154248, 0.001384232892,0.0009060795419
};



static float LPF128_coeff_BPF_Tone_N[128] = {
  0.0002170711523,-0.0002105281892,-0.0004841530172,-0.0006159361801,-0.0003409463679,
  0.0003460768785, 0.001084465417, 0.001321874093,0.0007124160184,-0.0005418128567,
  -0.001708026044,-0.001972825499,-0.001044134493,0.0005581053556, 0.001811624854,
   0.001922711381,0.0009358009556,-0.0003000028955,-0.0008393861935,-0.0004635759396,
    9.8680066e-05,-0.0001587214065,-0.001460265834,-0.002744261408,-0.002335644094,
  0.0005534236552, 0.004686338827,   0.0071768458, 0.005441396032,-0.0005674345884,
  -0.007667734288, -0.01118668355, -0.00819157809,0.0001008211184, 0.008730829693,
    0.01224189065, 0.008545648307,0.0004748748033,-0.006329423282,-0.007724994328,
  -0.004211606923,-0.0002650830429,-0.0002031267359,-0.003931757063,-0.006406462286,
  -0.001874059089,  0.01013856754,  0.02224718034,  0.02323346771, 0.006784470752,
   -0.02137763985, -0.04433615506, -0.04399481788, -0.01441362966,   0.0310801398,
    0.06548903883,  0.06450261921,  0.02350498736, -0.03667282313, -0.08057392389,
   -0.07979289442, -0.03180752322,  0.03680254892,  0.08574879169,  0.08574879169,
    0.03680254892, -0.03180752322, -0.07979289442, -0.08057392389, -0.03667282313,
    0.02350498736,  0.06450261921,  0.06548903883,   0.0310801398, -0.01441362966,
   -0.04399481788, -0.04433615506, -0.02137763985, 0.006784470752,  0.02323346771,
    0.02224718034,  0.01013856754,-0.001874059089,-0.006406462286,-0.003931757063,
  -0.0002031267359,-0.0002650830429,-0.004211606923,-0.007724994328,-0.006329423282,
  0.0004748748033, 0.008545648307,  0.01224189065, 0.008730829693,0.0001008211184,
   -0.00819157809, -0.01118668355,-0.007667734288,-0.0005674345884, 0.005441396032,
     0.0071768458, 0.004686338827,0.0005534236552,-0.002335644094,-0.002744261408,
  -0.001460265834,-0.0001587214065,  9.8680066e-05,-0.0004635759396,-0.0008393861935,
  -0.0003000028955,0.0009358009556, 0.001922711381, 0.001811624854,0.0005581053556,
  -0.001044134493,-0.001972825499,-0.001708026044,-0.0005418128567,0.0007124160184,
   0.001321874093, 0.001084465417,0.0003460768785,-0.0003409463679,-0.0006159361801,
  -0.0004841530172,-0.0002105281892,0.0002170711523
};


static float LPF128_coeff_BPF_Tone_M[128] = {
  0.0001812903793,-0.0003599256161,-0.0009992279811,-0.001237648539,-0.0005767047405,
  0.0005372471642, 0.001040326199,0.0005268109962,-8.466849977e-05,0.0003993230348,
   0.001772388583, 0.002406119136, 0.001263141399,-0.0005289728288,-0.0008980955463,
   0.000378114928, 0.001044148579,-0.0007828463567,-0.003753901459,-0.004550467711,
  -0.002191086067,0.0002638412989,-0.0005138163106,-0.003373550717,-0.003612281056,
  0.0008330270648, 0.005933316424, 0.006213671062, 0.002132129623,0.0001184450957,
    0.00414276449, 0.009566614404,  0.00836195983,-4.415857984e-05,-0.006851106416,
   -0.00487490138, 0.001282540616,0.0003759433166,   -0.010174945, -0.01905792579,
   -0.01476235595,-0.001549632056,  0.00449737208,-0.003428928787, -0.01196567994,
  -0.003761398373,   0.0181249287,  0.03084650077,   0.0204064399, 0.002312621335,
   0.003838665318,  0.02660037205,  0.03897264227,  0.01451732218, -0.02907010913,
     -0.045323845, -0.01860604249, 0.005619405769,  -0.0308539439,  -0.1180328727,
    -0.1636916101, -0.08104033023,   0.1068046615,   0.2650336623,   0.2650336623,
     0.1068046615, -0.08104033023,  -0.1636916101,  -0.1180328727,  -0.0308539439,
   0.005619405769, -0.01860604249,   -0.045323845, -0.02907010913,  0.01451732218,
    0.03897264227,  0.02660037205, 0.003838665318, 0.002312621335,   0.0204064399,
    0.03084650077,   0.0181249287,-0.003761398373, -0.01196567994,-0.003428928787,
    0.00449737208,-0.001549632056, -0.01476235595, -0.01905792579,   -0.010174945,
  0.0003759433166, 0.001282540616, -0.00487490138,-0.006851106416,-4.415857984e-05,
    0.00836195983, 0.009566614404,  0.00414276449,0.0001184450957, 0.002132129623,
   0.006213671062, 0.005933316424,0.0008330270648,-0.003612281056,-0.003373550717,
  -0.0005138163106,0.0002638412989,-0.002191086067,-0.004550467711,-0.003753901459,
  -0.0007828463567, 0.001044148579, 0.000378114928,-0.0008980955463,-0.0005289728288,
   0.001263141399, 0.002406119136, 0.001772388583,0.0003993230348,-8.466849977e-05,
  0.0005268109962, 0.001040326199,0.0005372471642,-0.0005767047405,-0.001237648539,
  -0.0009992279811,-0.0003599256161,0.0001812903793
};



static float LPF72_coeff_Decimation[72] = {
  -0.0003443412425,-0.0005081805866,-0.0007953237509, -0.00109184871,-0.001333431457,
  -0.001437614439,-0.001315868227,-0.0008889457094,-0.0001067138364, 0.001031007734,
    0.00245932932,  0.00403915951, 0.005560378078, 0.006757963914, 0.007343688514,
   0.007048260886, 0.005671376828, 0.003131892765,-0.0004891800927,-0.004922304302,
  -0.009705982171, -0.01421090961, -0.01769245043, -0.01936791651, -0.01851106063,
   -0.01455254294,-0.007173089776, 0.003624634352,   0.0174770765,  0.03366197646,
    0.05114474148,  0.06866631657,  0.08486375958,  0.09840977192,   0.1081543416,
     0.1132509187,   0.1132509187,   0.1081543416,  0.09840977192,  0.08486375958,
    0.06866631657,  0.05114474148,  0.03366197646,   0.0174770765, 0.003624634352,
  -0.007173089776, -0.01455254294, -0.01851106063, -0.01936791651, -0.01769245043,
   -0.01421090961,-0.009705982171,-0.004922304302,-0.0004891800927, 0.003131892765,
   0.005671376828, 0.007048260886, 0.007343688514, 0.006757963914, 0.005560378078,
    0.00403915951,  0.00245932932, 0.001031007734,-0.0001067138364,-0.0008889457094,
  -0.001315868227,-0.001437614439,-0.001333431457, -0.00109184871,-0.0007953237509,
  -0.0005081805866,-0.0003443412425
};


static float LPF72_coeff_Interpolation[72] = {
//  -3.283422484e-05,0.0003506981011,0.0007409456884, 0.001338474452, 0.002030009404, // До 5 кГц, -70 дБ, масштаб 50
//   0.002656923374, 0.003007102991, 0.002859616885, 0.002052052179,0.0005542031722,
//  -0.001475250465,-0.003672433319,-0.005509568844,-0.006397912279,-0.005838818382,
//  -0.003591002198, 0.000191436091, 0.004896650091, 0.009504125454,  0.01275784615,
//    0.01344542392,  0.01072909962, 0.004454592708,-0.004645901266, -0.01492665149,
//   -0.02401669882, -0.02920644917, -0.02798023634, -0.01858191378,-0.0004965977278,
//    0.02527338266,  0.05621649697,  0.08862889558,   0.1181944162,   0.1407228261,
//     0.1529006064,   0.1529006064,   0.1407228261,   0.1181944162,  0.08862889558,
//    0.05621649697,  0.02527338266,-0.0004965977278, -0.01858191378, -0.02798023634,
//   -0.02920644917, -0.02401669882, -0.01492665149,-0.004645901266, 0.004454592708,
//    0.01072909962,  0.01344542392,  0.01275784615, 0.009504125454, 0.004896650091,
//   0.000191436091,-0.003591002198,-0.005838818382,-0.006397912279,-0.005509568844,
//  -0.003672433319,-0.001475250465,0.0005542031722, 0.002052052179, 0.002859616885,
//   0.003007102991, 0.002656923374, 0.002030009404, 0.001338474452,0.0007409456884,
//  0.0003506981011,-3.283422484e-05
  
  
  
  
//   0.001670269761,-0.000362323859, -0.00136310386,-0.003046801081, -0.00535027124, // До 4 кГц, -40 дБ, масштаб 10
//  -0.008100885898, -0.01099869795, -0.01364021376, -0.01555877179, -0.01630172692,
//   -0.01551094465, -0.01301636547,-0.008893663064,-0.003504370339, 0.002523251111,
//   0.008339161985,  0.01301459502,  0.01565867849,  0.01559796557,  0.01252153423,
//    0.00658722315,-0.001529189292, -0.01067010965, -0.01931112632, -0.02575050481,
//   -0.02834974229, -0.02578504942, -0.01728034951,-0.002774100052,  0.01700112596,
//    0.04055773094,  0.06579464674,  0.09024135768,   0.1113640815,   0.1268903315,
//     0.1351119131,   0.1351119131,   0.1268903315,   0.1113640815,  0.09024135768,
//    0.06579464674,  0.04055773094,  0.01700112596,-0.002774100052, -0.01728034951,
//   -0.02578504942, -0.02834974229, -0.02575050481, -0.01931112632, -0.01067010965,
//  -0.001529189292,  0.00658722315,  0.01252153423,  0.01559796557,  0.01565867849,
//    0.01301459502, 0.008339161985, 0.002523251111,-0.003504370339,-0.008893663064,
//   -0.01301636547, -0.01551094465, -0.01630172692, -0.01555877179, -0.01364021376,
//   -0.01099869795,-0.008100885898, -0.00535027124,-0.003046801081, -0.00136310386,
//  -0.000362323859, 0.001670269761  
  
  
  
  -0.0005656601861,-0.0003935905988,-0.0002696058073,0.0001186760637,0.0007767195348, // До 5 кГц, -60 дБ, масштаб 10
   0.001610412262, 0.002418197459, 0.002920669504, 0.002833377803, 0.001955906395,
  0.0002742084907,-0.001978437416,-0.004315933678,-0.006078117993,-0.006584750954,
  -0.005336747505,-0.002217219677, 0.002374458825, 0.007505311631,  0.01184634306,
    0.01395411044,  0.01265078224, 0.007415564265,-0.001316136681, -0.01204058342,
   -0.02232444473, -0.02919686586, -0.02973835729, -0.02174751461,-0.004337617196,
    0.02168583311,  0.05377593264,  0.08796277642,   0.1194977611,   0.1437005252,
     0.1568366587,   0.1568366587,   0.1437005252,   0.1194977611,  0.08796277642,
    0.05377593264,  0.02168583311,-0.004337617196, -0.02174751461, -0.02973835729,
   -0.02919686586, -0.02232444473, -0.01204058342,-0.001316136681, 0.007415564265,
    0.01265078224,  0.01395411044,  0.01184634306, 0.007505311631, 0.002374458825,
  -0.002217219677,-0.005336747505,-0.006584750954,-0.006078117993,-0.004315933678,
  -0.001978437416,0.0002742084907, 0.001955906395, 0.002833377803, 0.002920669504,
   0.002418197459, 0.001610412262,0.0007767195348,0.0001186760637,-0.0002696058073,
  -0.0003935905988,-0.0005656601861  
};


static float LPF32_coeff_48k[32] = {
  -0.0007693853695,-0.002133627189,-0.004500244278,-0.007748364005, -0.01134580281,
   -0.01423283853, -0.01489570923, -0.01162227802,-0.002913234523,  0.01204120647,
    0.03295257688,   0.0582279861,  0.08507198095,   0.1099074706,   0.1290505379,
     0.1394745111,   0.1394745111,   0.1290505379,   0.1099074706,  0.08507198095,
     0.0582279861,  0.03295257688,  0.01204120647,-0.002913234523, -0.01162227802,
   -0.01489570923, -0.01423283853, -0.01134580281,-0.007748364005,-0.004500244278,
  -0.002133627189,-0.0007693853695
};


static float LPF128_coeff[128] = {
-0.000150986, 7.21E-05, 0.00010923, 0.000174259, 0.000266426, 0.000386199, 0.000534297, 0.000710912, 
0.000915392, 0.001145812, 0.00139884, 0.001669508, 0.001951234, 0.00223563, 0.002512803, 0.002771246, 
0.002998413, 0.003180734, 0.003304371, 0.00335538, 0.003320618, 0.003187876, 0.002947175, 0.002590479, 
0.002113938, 0.001516403, 0.000801271, -2.30E-05, -0.00094345, -0.001941763, -0.002994712, -0.004074049,
-0.005147172, -0.006177498, -0.007125421, -0.007948984, -0.008605306, -0.009051444, -0.009246012, 
-0.009150264, -0.008729681, -0.007955118, -0.006804204, -0.005262287, -0.003323608, -0.000991761, 
0.001719531, 0.004786565, 0.00817547, 0.011842536, 0.015735317, 0.019793164, 0.023948757, 0.028129468, 
0.032259166, 0.036259979, 0.040054318, 0.043566745, 0.046726212, 0.049467612, 0.051733803, 0.053477038, 
0.054660302, 0.055258345, 0.055258345, 0.054660302, 0.053477038, 0.051733803, 0.049467612, 0.046726212,
0.043566745, 0.040054318, 0.036259979, 0.032259166, 0.028129468, 0.023948757, 0.019793164, 0.015735317, 
0.011842536, 0.00817547, 0.004786565, 0.001719531, -0.000991761, -0.003323608, -0.005262287, -0.006804204, 
-0.007955118, -0.008729681, -0.009150264, -0.009246012, -0.009051444, -0.008605306, -0.007948984, -0.007125421,
-0.006177498, -0.005147172, -0.004074049, -0.002994712, -0.001941763, -0.00094345, -2.30E-05, 0.000801271, 
0.001516403, 0.002113938, 0.002590479, 0.002947175, 0.003187876, 0.003320618, 0.00335538, 0.003304371, 
0.003180734, 0.002998413, 0.002771246, 0.002512803, 0.00223563, 0.001951234, 0.001669508, 0.00139884, 
0.001145812, 0.000915392, 0.000710912, 0.000534297, 0.000386199, 0.000266426, 0.000174259, 0.00010923, 
7.21E-05, -0.000150986 
};
//******************************************************************************
// Секция прототипов локальных функций
//******************************************************************************
static void    uSD_audio_record         (float   In);
static int32_t rx_USB                   (int32_t In);
static int16_t tx_USB                   (int16_t In);
static int16_t tx_test_signal_tone      (int16_t In);
static int16_t tx_test_voice            (int16_t In);
static int16_t tx_voice_parott          (int16_t In);
static int16_t rx_rec_parott            (int16_t In);
static int16_t rx_play_parott           (int16_t In);
static int16_t fft_load                 (int16_t In);

static uint32_t create_RX_out (uint8_t Ch, float MA_Ch, float GA_Ch);           // Формирование выходного сигнала приемника из двух входов

static float   sql_tx                   (uint8_t *Enable);                      // Генерация сигнала но открытие шумоподавителя


static void    shift_buf                (float *in, uint16_t size);
static void    shift_buf_128            (float *In);
static float   LPF_128                  (float *in, float *coeff);
static float   LPF_128_I                (float *in, float *coeff);
static float   LPF_128_Q                (float *in, float *coeff);
static float   LPF_128_SIN              (float *in, float *coeff);
static float   LPF_128_COS              (float *in, float *coeff);
static void    AGC                      (float *in);


static void    shift_buf_72             (float *In);
static void    shift_buf_72_6           (float *In);
static float   LPF_72                   (float *in, float *coeff);
static void    shift_buf_32             (float *In);
static void    shift_buf_32_6           (float *In);
static float   LPF_32                   (float *in, float *coeff);
static uint32_t filter_S_meter          (uint32_t In);                  
static uint32_t convert_S_to_mkV        (uint32_t In, RX_GAIN_t Gain);

static uint16_t filter_current_TX       (uint16_t In);
static uint16_t filter_current_PWR      (uint16_t In);
static uint16_t adc_sample_to_mV        (uint16_t In, uint16_t RefADC);

static void     filter_interpolator_x6  (float *In, float *Coeff, float *Out);

static int16_t  set_PWR                 (float In, int32_t Pwr);                // Регулировка выходного сигнала в процентах от 0 до 100
//******************************************************************************
// Секция описания функций (сначала глобальных, потом локальных)
//******************************************************************************



//******************************************************************************
//   RX Обработчики прерываний DMA при приеме 48 сэмплов на АЦП кодека
//******************************************************************************
void HAL_I2SEx_TxRxHalfCpltCallback(I2S_HandleTypeDef *hi2s){                   // Half
    R.ADC_DataReady = HALF_RX;
    osSemaphoreRelease(myBinSem_DMA_ReadyHandle);                               //Выдем семафор о принятии в буфер сообщения
}

void HAL_I2SEx_TxRxCpltCallback(I2S_HandleTypeDef *hi2s){                       // Complete
static uint32_t Tick;  
  R.ADC_DataReady = COMPLETE_RX;
  osSemaphoreRelease(myBinSem_DMA_ReadyHandle);                                 //Выдем семафор о принятии в буфер сообщения
  if (++Tick == 250){
    Tick = 0;
    R.Tick_1s = 1;
  }
}



//******************************************************************************
//   TX Обработчики прерываний DMA при приеме 48 сэмплов на АЦП микрофона
//******************************************************************************
void adc_mic_half_dma_routine (void){
  int16_t i, Out;
  
  for (i=0; i<96;i++) {
//    dds16(&R.DDS_TX);
//    Out = R.DDS_TX.I * TX_OUT_AMP;
    
    //Out = HP_Filter(R.ADC_TX_buf[i]);
    
    Out = tx_USB(R.ADC_TX_buf[i]);
    
    if (Out >  1700) Out =  1700;                                               // Ограничение по амплитуде
    if (Out < -1700) Out = -1700;
    
    
    //Out = R.ADC_TX_buf[i] - 2047;
    
    //Out = (i*10) - 450;
    
    //Out = i;
    
    
    if (Out > 0) {      
      *(R.PWM_buf + (i*16) + 0) = Out; 
      *(R.PWM_buf + (i*16) + 1) = 0;
      *(R.PWM_buf + (i*16) + 2) = 0;
      *(R.PWM_buf + (i*16) + 3) = Out;
    } else {
      *(R.PWM_buf + (i*16) + 0) = 0; 
      *(R.PWM_buf + (i*16) + 1) = abs(Out);
      *(R.PWM_buf + (i*16) + 2) = abs(Out);
      *(R.PWM_buf + (i*16) + 3) = 0;
    }
    
    memcpy((R.PWM_buf + (i*16) + 4),   (R.PWM_buf + (i*16)), 8);
    memcpy((R.PWM_buf + (i*16) + 8),   (R.PWM_buf + (i*16)), 8);
    memcpy((R.PWM_buf + (i*16) + 12),  (R.PWM_buf + (i*16)), 8);
    
  }//for (i=0, i<ADC_TX_BUF_SIZE/2)


}


void adc_mic_complete_dma_routine (void){
int16_t i, Out;
int32_t Tmp;
  
  for (i=0; i<96; i++) {
//    dds16(&R.DDS_TX);
//    Out = R.DDS_TX.I * TX_OUT_AMP;
    
    //Out = HP_Filter(R.ADC_TX_buf[i + (ADC_TX_BUF_SIZE/2)]);
    
    Out = tx_USB(R.ADC_TX_buf[i + (ADC_TX_BUF_SIZE/2)]);
    
//    Tmp = Out * 2;
//    if (Tmp >  1700) Tmp =  1700;                                               // Ограничение по амплитуде
//    if (Tmp < -1700) Tmp = -1700;
//    Out = Tmp;
    
    
    if (Out >  1700) Out =  1700;                                               // Ограничение по амплитуде
    if (Out < -1700) Out = -1700;
    
    //Out = (R.ADC_TX_buf[i + (ADC_TX_BUF_SIZE/2)]) - 2047;
    
    //Out = (i*1) - 45;
    
    //Out = i* (-1);
    
    
    if (Out > 0) {      
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 0) = Out; 
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 1) = 0;
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 2) = 0;
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 3) = Out;
    } else {
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 0) = 0; 
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 1) = abs(Out);
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 2) = abs(Out);
      *(R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 3) = 0;
    }    
    
    memcpy((R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 4),   (R.PWM_buf + (i*16) + (PWM_BUF_SIZE/2)), 8);
    memcpy((R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 8),   (R.PWM_buf + (i*16) + (PWM_BUF_SIZE/2)), 8);
    memcpy((R.PWM_buf + (PWM_BUF_SIZE/2) + (i*16) + 12),  (R.PWM_buf + (i*16) + (PWM_BUF_SIZE/2)), 8);
  }//for (i=0, i<ADC_TX_BUF_SIZE/2)
  
}





//******************************************************************************
// Установить частоту DDS
//******************************************************************************
void set_DDS_freq (uint32_t Freq){
  R.DDS_RX.Freq = Freq;
}

//******************************************************************************
// Установить режим работы TRX - прием, передача
//******************************************************************************
void set_TXRX_mode (TXRX_MODE_e TXRX_Mode) {

  switch (TXRX_Mode){
    case RX:
      /*
      - Правый канал АЦП скоммутировать на IN1_R (магнитную антенну)
      - Левый канал скоммутировать на IN1_L (ГА антенну)
      
      */
      codec_RX_mode();
      
      // Включить прием
      //off_HW_TX();
      //on_HW_RX();
      //codec_IN1R_to_ADC();
      
      /*   Для включения приема нужно:
      - Отключить усилитель передатчика
      - Отключить настроечный конденсатор передатчика
      - Задержка
      - Отключить реле передатчика
      - Переключить обмотки приемной антенны последовательно
      - Отключить "закорот" входа МШУ 
      - Подключить настроечную емкость приемника (если нужно)
      - Включить УНЧ приемника
      */
      
      __TX_PA_OFF;
      __REL_TX_TUNE0_OFF;
      __REL_TX_TUNE1_OFF;
        osDelay(1);
      __REL_TX_ON_OFF;
      __REL_RX_COIL_SERIAL;
      __REL_RX_SHORT_OFF;
      __RX_PA_ON;
      
      
      
    break;
    
    case TX:                                                                    // Включить передачу голоса
      //off_HW_RX();
      //on_HW_TX();
      //codec_mic_to_left_phone();
      
      /*   Для включения передатчика нужно:
      - Отключить УНЧ приемника
      - Отключить настроечную емкость приемника
      - Включить "закорот" МШУ
      - Включить обмотки приемной антенны встречно
      - Включить реле антенны передатчика
      - Включить настроечную емкость передатчика
      - Задержка
      - Включить усилитель передатчика
      */
      
      __RX_PA_OFF;
      __REL_RX_TUNE0_OFF;
      __REL_RX_TUNE1_OFF;
      __REL_RX_SHORT_ON;
      __REL_RX_COIL_INVERS;
      __REL_TX_ON_ON;
        osDelay(1);
      __TX_PA_ON;
      
      
      
    break;
    
    case TX_TONE_1kHz:                                                          // Включить генерацию и передачу тона 1 кГц
      //off_HW_RX();
      //on_HW_TX();
      
      //__RX_PA_OFF;                                                            // На тоне усилитель не отключаем
      __REL_RX_TUNE0_OFF;
      __REL_RX_TUNE1_OFF;
      __REL_RX_SHORT_ON;
      __REL_RX_COIL_INVERS;
      __REL_TX_ON_ON;
        osDelay(1);
      __TX_PA_ON;
    break;
    
    
    case TEST_SIGNAL_VOICE:                                                     // Включить тестовый голосовой сигнал
      //off_HW_RX();
      //on_HW_TX();
      
      __RX_PA_OFF;
      __REL_RX_TUNE0_OFF;
      __REL_RX_TUNE1_OFF;
      __REL_RX_SHORT_ON;
      __REL_RX_COIL_INVERS;
      __REL_TX_ON_ON;
        osDelay(1);
      __TX_PA_ON;
    break;


    default:
    break;

  }



}

//******************************************************************************
//   Выключить периферию передатчика
//******************************************************************************
void off_HW_TX (void){
  
  __HAL_TIM_MOE_DISABLE_UNCONDITIONALLY(&htim1);                                // Выключить выход
  //__HAL_TIM_DISABLE(&htim1);                                                    // Останов ШИМ
  
  HAL_ADC_Stop_DMA(&hadc2);      // Стоп АЦП микрофона
           
};      





//******************************************************************************
//   Выключить периферию приемника
//******************************************************************************
void off_HW_RX (void){
//      __HAL_DMA_DISABLE_IT(&hdma_i2s2_ext_rx, DMA_IT_TC);                       // Запрет прерывания по наполнению DMA
//      __HAL_DMA_DISABLE_IT(&hdma_i2s2_ext_rx, DMA_IT_HT);

      //right_DAC_mute();
};                                                        



  

//******************************************************************************
//   Включить периферию передатчика
//******************************************************************************
void on_HW_TX  (void){


//      HAL_ADC_Start_DMA(&hadc2, (uint32_t*)R.ADC_TX_buf, ADC_TX_BUF_SIZE);      // Запуск АЦП микрофона
//      //__HAL_DMA_DISABLE_IT(&hdma_adc2, DMA_IT_HT);
//      __HAL_DMA_DISABLE_IT(&hdma_adc2, DMA_IT_TE);                              // Transfer error interrupt mask.
//      __HAL_DMA_DISABLE_IT(&hdma_adc2, DMA_IT_FE);                              // FIFO error interrupt mask.
//      __HAL_DMA_DISABLE_IT(&hdma_adc2, DMA_IT_DME);                             // Direct mode error interrupt.
//
//      
//      __HAL_TIM_MOE_ENABLE(&htim1); // Включить выход
};                                                        






//******************************************************************************
//   Включить периферию приемника
//******************************************************************************
void on_HW_RX  (void){

      __HAL_DMA_ENABLE_IT(&hdma_i2s2_ext_rx, DMA_IT_TC);                        // Разрешаем прерывания по наполнению DMA от кодека
      __HAL_DMA_ENABLE_IT(&hdma_i2s2_ext_rx, DMA_IT_HT);

      DAC_UNmute();                                                             // Включаем ЦАПы кодека
};                                                        



//******************************************************************************
//   Общая функция приемопередатчика
//******************************************************************************
/* Каждое (полу)наполнение буфера дает прерывание, в результате которого у нас есть флаг,
который говорит что нужно обработать 48 отсчетов

*/
void main_radio (void){
uint8_t i;
uint32_t Tmp_u32=0;

switch(R.TXRX_Mode){

case RX:
  //__LAMP_OFF; $$$
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2

              *((uint32_t*)(R.CodecTxData + i*2)) = rx_USB (*((uint32_t*)(R.CodecRxData + i*2)));

              Tmp_u32 += abs(*(R.CodecTxData + RIGHT_CH + (i*2)));              // For S meter

            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2

              *((uint32_t*)(R.CodecTxData + HALF_DMA_SHIFT + i*2)) = rx_USB (*((uint32_t*)(R.CodecRxData + HALF_DMA_SHIFT + i*2)));

              Tmp_u32 += *(R.CodecTxData + RIGHT_CH + HALF_DMA_SHIFT + (i*2));  // For S meter

            }
          break;
        default:
          break;
        }  
        R.S_meter = filter_S_meter(Tmp_u32);                                    // S meter
        R.S_meter_mkv = convert_S_to_mkV(R.S_meter, R.RX_gain);
break;
  
  
  
case TX:
//  __LAMP_ON; $$$
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH  + (i*2)) = tx_USB (*(R.CodecRxData + LEFT_CH + (i*2)));
              *(R.CodecTxData + RIGHT_CH + (i*2)) = 0;
            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH  + HALF_DMA_SHIFT + (i*2)) = tx_USB (*(R.CodecRxData + HALF_DMA_SHIFT + LEFT_CH + (i*2)));
              *(R.CodecTxData + RIGHT_CH + HALF_DMA_SHIFT + (i*2)) = 0;
            }
          break;
        default: 
          break;
        }   
break;  


case TX_TONE_1kHz:
//  __LAMP_ON;  $$$
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + (i*2)) = tx_test_signal_tone (*(R.CodecRxData + LEFT_CH + (i*2)));
            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + HALF_DMA_SHIFT + (i*2)) = tx_test_signal_tone (*(R.CodecRxData + HALF_DMA_SHIFT + LEFT_CH + (i*2)));
            }
          break;
        default:
          break;
        }   
break;
  
  
  
case TEST_SIGNAL_VOICE:
//  __LAMP_ON; $$$
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + (i*2)) = tx_test_voice (*(R.CodecRxData + LEFT_CH + (i*2)));
            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + HALF_DMA_SHIFT + (i*2)) = tx_test_voice (*(R.CodecRxData + HALF_DMA_SHIFT + LEFT_CH + (i*2)));
            }
          break;
        default:
          break;
        }   
break;

//---   PAROTT   ---------------------------------------------------------------
case PAROTT_TEST_SIGNAL:
//  __LAMP_ON; $$$
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + (i*2)) = tx_voice_parott (*(R.CodecRxData + LEFT_CH + (i*2)));
            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + HALF_DMA_SHIFT + (i*2)) = tx_voice_parott (*(R.CodecRxData + HALF_DMA_SHIFT + LEFT_CH + (i*2)));
            }
          break;
        default:
          break;
        }   
break;


case PAROTT_REC:
//$$$  __LAMP_OFF;
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + RIGHT_CH + (i*2)) = rx_rec_parott (*(R.CodecRxData + RIGHT_CH + (i*2)));
            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + RIGHT_CH + HALF_DMA_SHIFT + (i*2)) = rx_rec_parott (*(R.CodecRxData + HALF_DMA_SHIFT + RIGHT_CH + (i*2)));
            }
          break;
        default:
          break;
        }   
break;


case PAROTT_PLAY:
//$$$  __LAMP_ON;
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + (i*2)) = rx_play_parott (*(R.CodecRxData + RIGHT_CH + (i*2)));
            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + LEFT_CH + HALF_DMA_SHIFT + (i*2)) = rx_play_parott (*(R.CodecRxData + HALF_DMA_SHIFT + RIGHT_CH + (i*2)));
            }
          break;
        default:
          break;
        }   
break;

case FFT:
//$$$  __LAMP_OFF;
        switch (R.ADC_DataReady){
          case HALF_RX:                                                         //  HALF 
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + RIGHT_CH + (i*2)) = fft_load (*(R.CodecRxData + RIGHT_CH + (i*2)));
              *(R.CodecTxData + LEFT_CH  + (i*2)) = 0;
            }
          break;
          
          case COMPLETE_RX:                                                     // COMPLETE
            for (i=0;i<(HALF_DMA_SHIFT/2);i++){                                 //  В начало буфера передачи положить 48 отсчетов для DAC, с шагом 2
              *(R.CodecTxData + RIGHT_CH + HALF_DMA_SHIFT + (i*2)) = fft_load (*(R.CodecRxData + HALF_DMA_SHIFT + RIGHT_CH + (i*2)));
              *(R.CodecTxData + LEFT_CH  + HALF_DMA_SHIFT + (i*2)) = 0;
            }
          break;
        default:
          break;
        }  
break;
  
}
//__LED2_ON;
}

//******************************************************************************
//   Приемник USB voice
//******************************************************************************
/*
Берем на вход отсчет АЦП с дискретизацией 48828 кГц и такой же отсчет кладем на выход.

*/
static int32_t rx_USB (int32_t In){
float Tmp_f;
uint32_t Out_u32;
  
  __LED2_ON;
  
  // MAGNIT --------------------------------------------------------------------
  R.SSB_Out_F = 0;                                                              // Подготовка

  R.Tmp_i32 = HP_Filter(In>>16);                                                // Для явной конверсии в int32. Старшие биты - правый канал
  
  dds16(&R.DDS_RX);                                                             // Генерируем два отсчета I и Q

  R.Buf_LPF_48k_I[R.Buf_LPF_48k_idx + 66] = R.DDS_RX.I * R.Tmp_i32 * 15;        // Первый смеситель. Домножение - компенсация потерь в дециматоре
  R.Buf_LPF_48k_Q[R.Buf_LPF_48k_idx + 66] = R.DDS_RX.Q * R.Tmp_i32 * 15;
  
  R.SSB_Out_F = R.Buf_48k_Out[R.Buf_LPF_48k_idx];                               // Выходной отсчет из буфера интерполятора
  //============================================================================
  
  
  // GA ------------------------------------------------------------------------
  R.GA_SSB_Out_F = 0;                                                           // Подготовка

  R.Tmp_i32 = HP_Filter_GA(In & 0xFFFF);                                           // Для явной конверсии в int32. Только младшие биты - левый канал
  
  dds16(&R.DDS_GA);                                                             // Генерируем два отсчета I и Q

  R.GA_Buf_LPF_48k_I[R.Buf_LPF_48k_idx + 66] = R.DDS_GA.I * R.Tmp_i32 * 15;  // Первый смеситель. Домножение - компенсация потерь в дециматоре
  R.GA_Buf_LPF_48k_Q[R.Buf_LPF_48k_idx + 66] = R.DDS_GA.Q * R.Tmp_i32 * 15;
  
  R.GA_SSB_Out_F = R.GA_Buf_48k_Out[R.GA_Buf_LPF_48k_idx];                      // Выходной отсчет из буфера интерполятора
  //============================================================================
  
  // Домен 8 кГц
  if(++R.Buf_LPF_48k_idx == 6) {                                                // Если не накопилось 6 отсчетов - сразу на выход
  
    
  // MAGNIT --------------------------------------------------------------------  
  R.Buf_LPF_48k_idx = 0;                                                        // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

  R.Buf_LPF_8k_I[127] = LPF_72 (R.Buf_LPF_48k_I, LPF72_coeff_Decimation);       // Фильтр дециматор в конец поворачивающего фильтра
  R.Buf_LPF_8k_Q[127] = LPF_72 (R.Buf_LPF_48k_Q, LPF72_coeff_Decimation);
  shift_buf_72_6 (R.Buf_LPF_48k_I);                                             // Сдвиг буфера дециматора на 6 - подготовка к новому циклу
  shift_buf_72_6 (R.Buf_LPF_48k_Q);
  
  
  R.TmpI = LPF_128_SIN (R.Buf_LPF_8k_I, LPF128_coeff_FOS);                          // Применяем поворачивающий фильтр основной селекции
  R.TmpQ = LPF_128_COS (R.Buf_LPF_8k_Q, LPF128_coeff_FOS);
  shift_buf_128(R.Buf_LPF_8k_I);                                                // Сдвигаем буфера - готовим к новому циклу
  shift_buf_128(R.Buf_LPF_8k_Q);
  
  //__HAL_DMA_DISABLE(&hdma_memtomem_dma2_stream1);
  //__HAL_DMA_DISABLE(&hdma_memtomem_dma2_stream2);
  //HAL_DMA_Start(&hdma_memtomem_dma2_stream1, (uint32_t)(R.Buf_LPF_8k_I+1), (int32_t)(R.Buf_LPF_8k_I+0), 127*1);
  //HAL_DMA_Start(&hdma_memtomem_dma2_stream2, (uint32_t)(R.Buf_LPF_8k_Q+1), (int32_t)(R.Buf_LPF_8k_Q+0), 127*1);
  
  if (R.USB_On) R.Buf_BPF_8k[127] = (R.TmpI - R.TmpQ) ;                         // Формируем выходной USB низкочастотный сигнал в последний элемент буфера полосового филльтра
  else R.Buf_BPF_8k[127] = (R.TmpI + R.TmpQ) ;                                  // LSB
  
  switch (R.RXBW){                                                              // Применяем полосовой фильтр и укладываем в интерполятор новый отсчет
  case RXBW_NARROW:                                                     
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF_Tone_N);   // Узкая полоса 400 Гц
    break;
  case RXBW_MEDIUM:
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF_Tone_M);   // Средняя пооса 1 кГц
    break;
  case RXBW_WIDE:
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
    break;
  default:
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
  }
  
  //---   Эквалайзер   -----------------------------------------------------
  if (R.EqRx_En){
//    Tmp_f = allpass(&R.EqRxLow,  R.Buf_48k_Out_Work[11]);
//    Tmp_f = allpass(&R.EqRxMed,  Tmp_f);
//    R.Buf_48k_Out_Work[11] = allpass(&R.EqRxHigh, Tmp_f);
//    R.Buf_48k_Out_Work[11] = allpass(&R.EqRxHigh,  R.Buf_48k_Out_Work[11]);
  }
  //------------------------------------------------------------------------
  
  //if (R.AGC.Enable) AGC (&R.Buf_48k_Out_Work[11]);                              // Применяем АРУ, если включена
  
  R.Buf_48k_Out_Work[11] = squelch_N (R.Buf_48k_Out_Work[11], &R.RXSQL);          // Шумоподавитель
  
  //---   uSD audio record   ---------------------------------------------------
  uSD_audio_record(R.Buf_48k_Out_Work[11]);
  //----------------------------------------------------------------------------
  
        
  shift_buf_128(R.Buf_BPF_8k);                                                  // Сдвиг буфера полосового фильтра
  
  filter_interpolator_x6 (R.Buf_48k_Out_Work, LPF72_coeff_Interpolation, R.Buf_48k_Out); // Применяем интерполятор.
  shift_buf (R.Buf_48k_Out_Work, 12);                                           // Сдвиг буфера интерполятора на 1 отсчет
  //============================================================================


  // GA ------------------------------------------------------------------------  
  //R.GA_Buf_LPF_48k_idx = 0;                                                        // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

  R.GA_Buf_LPF_8k_I[127] = LPF_72 (R.GA_Buf_LPF_48k_I, LPF72_coeff_Decimation);       // Фильтр дециматор в конец поворачивающего фильтра
  R.GA_Buf_LPF_8k_Q[127] = LPF_72 (R.GA_Buf_LPF_48k_Q, LPF72_coeff_Decimation);
  shift_buf_72_6 (R.GA_Buf_LPF_48k_I);                                             // Сдвиг буфера дециматора на 6 - подготовка к новому циклу
  shift_buf_72_6 (R.GA_Buf_LPF_48k_Q);
  
  
  R.TmpI = LPF_128_SIN (R.GA_Buf_LPF_8k_I, LPF128_coeff_FOS);                            // Применяем поворачивающий фильтр основной селекции
  R.TmpQ = LPF_128_COS (R.GA_Buf_LPF_8k_Q, LPF128_coeff_FOS);
  shift_buf_128(R.GA_Buf_LPF_8k_I);                                                // Сдвигаем буфера - готовим к новому циклу
  shift_buf_128(R.GA_Buf_LPF_8k_Q);
  
  R.GA_USB_On = 1;
  if (R.GA_USB_On) R.GA_Buf_BPF_8k[127] = (R.TmpI - R.TmpQ) ;                         // Формируем выходной USB низкочастотный сигнал в последний элемент буфера полосового филльтра
  else R.GA_Buf_BPF_8k[127] = (R.TmpI + R.TmpQ) ;                                  // LSB
  
  
  R.GA_RXBW = RXBW_WIDE;
  switch (R.GA_RXBW){                                                              // Применяем полосовой фильтр и укладываем в интерполятор новый отсчет
  case RXBW_NARROW:                                                     
    R.GA_Buf_48k_Out_Work[11] = LPF_128 (R.GA_Buf_BPF_8k, LPF128_coeff_BPF_Tone_N);   // Узкая полоса 400 Гц
    break;
  case RXBW_MEDIUM:
    R.GA_Buf_48k_Out_Work[11] = LPF_128 (R.GA_Buf_BPF_8k, LPF128_coeff_BPF_Tone_M);   // Средняя пооса 1 кГц
    break;
  case RXBW_WIDE:
    R.GA_Buf_48k_Out_Work[11] = LPF_128 (R.GA_Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
    break;
  default:
    R.GA_Buf_48k_Out_Work[11] = LPF_128 (R.GA_Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
  }

        
  shift_buf_128(R.GA_Buf_BPF_8k);                                                  // Сдвиг буфера полосового фильтра
  
  filter_interpolator_x6 (R.GA_Buf_48k_Out_Work, LPF72_coeff_Interpolation, R.GA_Buf_48k_Out); // Применяем интерполятор.
  shift_buf (R.GA_Buf_48k_Out_Work, 12);                                           // Сдвиг буфера интерполятора на 1 отсчет
  //============================================================================




  
  }// Конец домена 8 кГц
    
  
  if (R.RXBW == RXBW_BYPASS) R.SSB_Out_F = In;

//  //return R.SSB_Out_F;
//
//  int32_t Tmp  = (int16_t)R.GA_SSB_Out_F;                                           // Явно выход превращаем в int16
//          Tmp += (int16_t)R.SSB_Out_F;
//
//  Out_u32 = (Tmp << 16);                                                        // Сдвигаем в правый канал
//  
            __LED2_OFF;
//            
//        
//  return Out_u32;  
            
//#define SILENCE         0
//#define MA              1
//#define GA              2
//#define MAGA            3 

  return create_RX_out (1, R.SSB_Out_F, R.GA_SSB_Out_F);

}




//******************************************************************************
//   Передатчиик USB voice
//******************************************************************************
static int16_t tx_USB (int16_t In){
float Tmp_f;
  
  R.SSB_Out_F = 0;                                                              // Подготовка
  
  R.Buf_LPF_48k_I[R.Buf_LPF_48k_idx + 66] = In * 6;                             // Набираем 6 отсчетов в буфер микрофонного дециматора


  //---   MAGNIT   -------------------------------------------------------------
  R.SSB_Out_F = R.Buf_48k_Out[R.Buf_LPF_48k_idx] * 20;                          // Выходной отсчет из буфера интерполятора
  //============================================================================
  
  
  
  
  //---   GA   -----------------------------------------------------------------
  R.GA_SSB_Out_F = R.GA_Buf_48k_Out[R.Buf_LPF_48k_idx] * 20;                    // Выходной отсчет из буфера интерполятора
  //============================================================================
  
  
  
  // Домен 8 кГц
  if(++R.Buf_LPF_48k_idx == 6) { 
      R.Buf_LPF_48k_idx = 0;                                                    // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

      Tmp_f = LPF_72 (R.Buf_LPF_48k_I, LPF72_coeff_Interpolation);              // Фильтр дециматор
      
      //---   Эквалайзер   -----------------------------------------------------
      if (R.EqTx_En){
//        Tmp_f = allpass(&R.EqTxLow,  Tmp_f);
//        Tmp_f = allpass(&R.EqTxMed,  Tmp_f);
//        Tmp_f = allpass(&R.EqTxHigh, Tmp_f);
      }
      //------------------------------------------------------------------------
      
      R.Buf_BPF_8k  [127] = Tmp_f;                                              // Фильтр дециматор в фильтр корректор
      shift_buf_72_6 (R.Buf_LPF_48k_I);                                         // Сдвиг буфера дециматора на 6 - подготовка к новому циклу

      R.Buf_LPF_8k_I[127] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF);
      R.Buf_LPF_8k_Q[127] = R.Buf_LPF_8k_I[127];
      
      if (R.SQL_Enable){                                                        // Сигнал отрытия шумоподавителя на N тактов после разрешения шумоподавителя
          R.Buf_LPF_8k_I[127] = sql_tx(&(R.SQL_Enable));
          R.Buf_LPF_8k_Q[127] = R.Buf_LPF_8k_I[127];
      }
      
      
      shift_buf_128(R.Buf_BPF_8k);                                              // Сдвиг фильтра корректора  
      
      //---   uSD audio record   ---------------------------------------------------
      uSD_audio_record(R.Buf_BPF_8k  [127]);
      //----------------------------------------------------------------------------


      R.Buf_48k_Out_Work[11]   = LPF_128_SIN (R.Buf_LPF_8k_I, LPF128_coeff_FOS);// Применяем поворачивающий фильтр основной селекции
      R.Buf_48k_Out_Work_Q[11] = LPF_128_COS (R.Buf_LPF_8k_Q, LPF128_coeff_FOS);
      shift_buf_128(R.Buf_LPF_8k_I);                                            // Сдвигаем буфера - готовим к новому циклу
      shift_buf_128(R.Buf_LPF_8k_Q);
      
      // Интерполируем отсчеты
      filter_interpolator_x6 (R.Buf_48k_Out_Work,   LPF72_coeff_Interpolation, R.Buf_48k_Out);   // Применяем интерполятор.
      filter_interpolator_x6 (R.Buf_48k_Out_Work_Q, LPF72_coeff_Interpolation, R.Buf_48k_Out_Q); // Применяем интерполятор.
      shift_buf (R.Buf_48k_Out_Work, 12);                                       // Сдвиг буфера интерполятора на 1 отсчет
      shift_buf (R.Buf_48k_Out_Work_Q, 12);                                     // Сдвиг буфера интерполятора на 1 отсчет
      
      
      
      
      for (uint8_t i=0;i<6;i++){                                                // Для каждого интерполированного отсчета
        
        //---   MAGNIT   -------------------------------------------------------
        dds16(&R.DDS_TX);                                                       // Генерируем два отсчета I и Q
        R.Buf_48k_Out[i]   *= R.DDS_TX.Q;                                       // Домножаем квадратурно на несущую
        R.Buf_48k_Out_Q[i] *= R.DDS_TX.I;
        if (R.USB_On) R.Buf_48k_Out[i]   += R.Buf_48k_Out_Q[i];                 // Формируем выходной сигнал USB
        else R.Buf_48k_Out[i]            -= R.Buf_48k_Out_Q[i];                 // Формируем выходной сигнал LSB
        //======================================================================
        
        
        //---   GA   -----------------------------------------------------------
        dds16(&R.DDS_GA);                                                       // Генерируем два отсчета I и Q
        R.GA_Buf_48k_Out[i]   *= R.DDS_GA.Q;                                    // Домножаем квадратурно на несущую
        R.GA_Buf_48k_Out_Q[i] *= R.DDS_GA.I;
        if (R.GA_USB_On) R.GA_Buf_48k_Out[i] -= R.GA_Buf_48k_Out_Q[i];          // Формируем выходной сигнал USB
        else             R.GA_Buf_48k_Out[i] += R.GA_Buf_48k_Out_Q[i];          // Формируем выходной сигнал LSB
        //======================================================================
        
      }
      
      
      
      

      
  }// Конец домена 8 кГц


  return set_PWR (R.SSB_Out_F, R.TX_pwr);
}






//******************************************************************************
//   Генерация сигнала на открытие шумоподавителя
//******************************************************************************
/**
Функция управляется переменной uint8_t SQL_Enable из реестра.
Функция вызывается с частотой 8 кГц
Выдает на выход отсчеты FSK100 сигнала формирующие команду на открытие шумоподавителя
*/
static float sql_tx (uint8_t *Enable){

}                                








//******************************************************************************
//    Тестовый тоновый сигнал
//******************************************************************************
static int16_t tx_test_signal_tone      (int16_t In){
static uint8_t Cnt;             // Делать домен 8 кГц
static uint16_t Cnt2;           // Делать прерывистый звуковой сигнал
float Tmp;

    R.DDS_AUX.Fdiskr = 48828;
    R.DDS_AUX.Freq = R.Test_tone_freq + R.DDS_TX.Freq;
    dds16(&R.DDS_AUX);
    Tmp = R.DDS_AUX.I * TX_TONE_AMP;
   
   
    if (++Cnt==6){                                                              // Домен 8 кГц
      Cnt = 0;
      //---   uSD audio record   -----------------------------------------------
      uSD_audio_record(Tmp/4);
      //------------------------------------------------------------------------
            
      //---  Счетчик времени для  генератора прерывистости тонового сигнала  ---
      if (++Cnt2 >= 16000) {                    // Период 2 сек
        Cnt2 = 0;
      }
      //------------------------------------------------------------------------
      
      
    }
    
    
    //---   Генерация прерывистости тонового сигнала   -----------------------
    if (R.Tone_Puls) {                      // Если разрешено пиканье
      if (Cnt2 > 8000) {                    // Вторую половину периода 
        Tmp = 0;                            // Делаем тишину
      }
    }
    
    return set_PWR (Tmp, R.TX_pwr);
}



//******************************************************************************
//    Тестовое голосовое сообщение для непрерывного воспроизведения
//******************************************************************************
static int16_t tx_test_voice            (int16_t In){
  R.SSB_Out_F = 0;                                                              // Подготовка
  
  R.SSB_Out_F = R.Buf_48k_Out[R.Buf_LPF_48k_idx] * 20;                               // Выходной отсчет из буфера интерполятора

  // Домен 8 кГц
  if(++R.Buf_LPF_48k_idx == 6) { 
      R.Buf_LPF_48k_idx = 0;                                                    // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

      if (++R.RecBufIdx < sizeof(test_tone_8bit_pcm)) {                     // Вычитываем буфер с записанным в ФЛЭШ сообщением
        R.Buf_LPF_8k_I[127] = test_tone_8bit_pcm[R.RecBufIdx] << 7;      // При 8 немного искажения
        R.Buf_LPF_8k_Q[127] = test_tone_8bit_pcm[R.RecBufIdx] << 7;
              //---   uSD audio record   ---------------------------------------
              uSD_audio_record((float)test_tone_8bit_pcm[R.RecBufIdx]);
              //----------------------------------------------------------------
      }
      else {
        R.RecBufIdx = 0;
      }
      
      

      R.Buf_48k_Out_Work[11]   = LPF_128 (R.Buf_LPF_8k_I, LPF128_coeff_I);      // Применяем поворачивающий фильтр основной селекции
      R.Buf_48k_Out_Work_Q[11] = LPF_128 (R.Buf_LPF_8k_Q, LPF128_coeff_Q);
      shift_buf_128(R.Buf_LPF_8k_I);                                            // Сдвигаем буфера - готовим к новому циклу
      shift_buf_128(R.Buf_LPF_8k_Q);
      
      // Интерполируем отсчеты
      filter_interpolator_x6 (R.Buf_48k_Out_Work,   LPF72_coeff_Interpolation, R.Buf_48k_Out);   // Применяем интерполятор.
      filter_interpolator_x6 (R.Buf_48k_Out_Work_Q, LPF72_coeff_Interpolation, R.Buf_48k_Out_Q); // Применяем интерполятор.
      shift_buf (R.Buf_48k_Out_Work, 12);                                       // Сдвиг буфера интерполятора на 1 отсчет
      shift_buf (R.Buf_48k_Out_Work_Q, 12);                                     // Сдвиг буфера интерполятора на 1 отсчет
      
      for (uint8_t i=0;i<6;i++){                                                // Для каждого интерполированного отсчета
        dds16(&R.DDS_TX);                                                       // Генерируем два отсчета I и Q
        R.Buf_48k_Out[i]   *= R.DDS_TX.Q;                                       // Домножаем квадратурно на несущую
        R.Buf_48k_Out_Q[i] *= R.DDS_TX.I;
        if (R.USB_On) R.Buf_48k_Out[i]   += R.Buf_48k_Out_Q[i];                 // Формируем выходной сигнал USB
        else R.Buf_48k_Out[i]            -= R.Buf_48k_Out_Q[i];                 // Формируем выходной сигнал LSB
      }
  }// Конец домена 8 кГц


  return set_PWR (R.SSB_Out_F, R.TX_pwr);
}

//******************************************************************************
//    Тестовое голосовое сообщение эхорепитера
//******************************************************************************
static int16_t tx_voice_parott          (int16_t In){
  

  R.SSB_Out_F = 0;                                                              // Подготовка
  
  R.SSB_Out_F = R.Buf_48k_Out[R.Buf_LPF_48k_idx] * 20;                          // Выходной отсчет из буфера интерполятора

  // Домен 8 кГц
  if(++R.Buf_LPF_48k_idx == 6) { 
      R.Buf_LPF_48k_idx = 0;                                                    // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

      if (++R.RecBufIdx < sizeof(test_tone_8bit_pcm)) {                         // Вычитываем буфер с записанным в ФЛЭШ сообщением
        R.Buf_LPF_8k_I[127] = test_tone_8bit_pcm[R.RecBufIdx] << 7;             // При 8 немного искажения
        R.Buf_LPF_8k_Q[127] = test_tone_8bit_pcm[R.RecBufIdx] << 7;
      }
      else {
        R.RecBufIdx = 0;
        R.TXRX_Mode = PAROTT_REC;
      }
      
      //---   uSD audio record   -----------------------------------------------
      uSD_audio_record(R.Buf_LPF_8k_I[127]/4);
      //------------------------------------------------------------------------

      R.Buf_48k_Out_Work[11]   = LPF_128 (R.Buf_LPF_8k_I, LPF128_coeff_I);      // Применяем поворачивающий фильтр основной селекции
      R.Buf_48k_Out_Work_Q[11] = LPF_128 (R.Buf_LPF_8k_Q, LPF128_coeff_Q);
      shift_buf_128(R.Buf_LPF_8k_I);                                            // Сдвигаем буфера - готовим к новому циклу
      shift_buf_128(R.Buf_LPF_8k_Q);
      
      // Интерполируем отсчеты
      filter_interpolator_x6 (R.Buf_48k_Out_Work,   LPF72_coeff_Interpolation, R.Buf_48k_Out);   // Применяем интерполятор.
      filter_interpolator_x6 (R.Buf_48k_Out_Work_Q, LPF72_coeff_Interpolation, R.Buf_48k_Out_Q); // Применяем интерполятор.
      shift_buf (R.Buf_48k_Out_Work, 12);                                       // Сдвиг буфера интерполятора на 1 отсчет
      shift_buf (R.Buf_48k_Out_Work_Q, 12);                                     // Сдвиг буфера интерполятора на 1 отсчет
      
      for (uint8_t i=0;i<6;i++){                                                // Для каждого интерполированного отсчета
        dds16(&R.DDS_TX);                                                       // Генерируем два отсчета I и Q
        R.Buf_48k_Out[i]   *= R.DDS_TX.Q;                                       // Домножаем квадратурно на несущую
        R.Buf_48k_Out_Q[i] *= R.DDS_TX.I;
        R.Buf_48k_Out[i]   += R.Buf_48k_Out_Q[i];                               // Формируем выходной сигнал
      }
  }// Конец домена 8 кГц


  return set_PWR (R.SSB_Out_F, R.TX_pwr);
}



//******************************************************************************
//    Запись сообщения эхорепитера
//******************************************************************************
static int16_t rx_rec_parott            (int16_t In){
  
  
  R.SSB_Out_F = 0;                                                              // Подготовка

  R.Tmp_i32 = HP_Filter(In);                                                    // Для явной конверсии в int32
  
  dds16(&R.DDS_RX);                                                             // Генерируем два отсчета I и Q

  R.Buf_LPF_48k_I[R.Buf_LPF_48k_idx + 66] = R.DDS_RX.I * R.Tmp_i32 * 15;        // Первый смеситель. Домножение - компенсация потерь в дециматоре
  R.Buf_LPF_48k_Q[R.Buf_LPF_48k_idx + 66] = R.DDS_RX.Q * R.Tmp_i32 * 15;
  
  R.SSB_Out_F = R.Buf_48k_Out[R.Buf_LPF_48k_idx];                               // Выходной отсчет из буфера интерполятора
  
  // Домен 8 кГц
  if(++R.Buf_LPF_48k_idx == 6) {                                                // Если не накопилось 6 отсчетов - сразу на выход
  
  R.Buf_LPF_48k_idx = 0;                                                        // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

  R.Buf_LPF_8k_I[127] = LPF_72 (R.Buf_LPF_48k_I, LPF72_coeff_Decimation);       // Фильтр дециматор в конец поворачивающего фильтра
  R.Buf_LPF_8k_Q[127] = LPF_72 (R.Buf_LPF_48k_Q, LPF72_coeff_Decimation);
  shift_buf_72_6 (R.Buf_LPF_48k_I);                                             // Сдвиг буфера дециматора на 6 - подготовка к новому циклу
  shift_buf_72_6 (R.Buf_LPF_48k_Q);
  
  
  R.TmpI = LPF_128 (R.Buf_LPF_8k_I, LPF128_coeff_I);                            // Применяем поворачивающий фильтр основной селекции
  R.TmpQ = LPF_128 (R.Buf_LPF_8k_Q, LPF128_coeff_Q);
  shift_buf_128(R.Buf_LPF_8k_I);                                                // Сдвигаем буфера - готовим к новому циклу
  shift_buf_128(R.Buf_LPF_8k_Q);
  
  R.Buf_BPF_8k[127] = (R.TmpI + R.TmpQ) ;                                       // Формируем выходной низкочастотный сигнал в последний элемент буфера полосового филльтра
  
  
  switch (R.RXBW){                                                              // Применяем полосовой фильтр и укладываем в интерполятор новый отсчет
  case RXBW_NARROW:                                                     
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF_Tone_N);   // Узкая полоса 400 Гц
    break;
  case RXBW_MEDIUM:
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF_Tone_M);   // Средняя пооса 1 кГц
    break;
  case RXBW_WIDE:
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
    break;
  default:
    R.Buf_48k_Out_Work[11] = LPF_128 (R.Buf_BPF_8k, LPF128_coeff_BPF);          // Широкая полоса 3 кГц
  }
  
  //---   uSD audio record   ---------------------------------------------------
      uSD_audio_record(R.Buf_48k_Out_Work[11]);
  //----------------------------------------------------------------------------
  
  //---   Parott Recorder   ----------------------------------------------------
  if (++R.RecBufIdx < REC_BUF_SIZE) {                                           // Fill bufer
    R.RecBuf[R.RecBufIdx] =  R.Buf_48k_Out_Work[11];                            // При 8 немного искажения
  }
  else {
    R.RecBufIdx = 0;                                                    // Готовим 
    R.TXRX_Mode = PAROTT_PLAY;
  }
        
  shift_buf_128(R.Buf_BPF_8k);                                                  // Сдвиг буфера полосового фильтра
  
  filter_interpolator_x6 (R.Buf_48k_Out_Work, LPF72_coeff_Interpolation, R.Buf_48k_Out); // Применяем интерполятор.
  shift_buf (R.Buf_48k_Out_Work, 12);                                           // Сдвиг буфера интерполятора на 1 отсчет
    
  }// Конец домена 8 кГц
    

return R.SSB_Out_F;  
}



//******************************************************************************
//    Воспроизведение записанного сообщения эхорепитера
//******************************************************************************
static int16_t rx_play_parott           (int16_t In){
  
  R.SSB_Out_F = 0;                                                              // Подготовка
  
  R.SSB_Out_F = R.Buf_48k_Out[R.Buf_LPF_48k_idx] * 40;                          // Выходной отсчет из буфера интерполятора

  // Домен 8 кГц
  if(++R.Buf_LPF_48k_idx == 6) { 
      R.Buf_LPF_48k_idx = 0;                                                    // Здесь начинается домен 8138 Гц. Подготовка к новому циклу.

      
      //---   Recorder PLAY   ------------------------------------------------------
      if (++R.RecBufIdx < sizeof(test_tone_8bit_pcm)) {                         // Вычитываем буфер с записанным в ФЛЭШ сообщением
        R.Buf_LPF_8k_I[127] = R.RecBuf[R.RecBufIdx];                            // 
        R.Buf_LPF_8k_Q[127] = R.RecBuf[R.RecBufIdx];
      }
      else {
        R.RecBufIdx = 0;
        R.TXRX_Mode = PAROTT_TEST_SIGNAL;
      }

      R.Buf_48k_Out_Work[11]   = LPF_128 (R.Buf_LPF_8k_I, LPF128_coeff_I);      // Применяем поворачивающий фильтр основной селекции
      R.Buf_48k_Out_Work_Q[11] = LPF_128 (R.Buf_LPF_8k_Q, LPF128_coeff_Q);
      shift_buf_128(R.Buf_LPF_8k_I);                                            // Сдвигаем буфера - готовим к новому циклу
      shift_buf_128(R.Buf_LPF_8k_Q);
      
      // Интерполируем отсчеты
      filter_interpolator_x6 (R.Buf_48k_Out_Work,   LPF72_coeff_Interpolation, R.Buf_48k_Out);   // Применяем интерполятор.
      filter_interpolator_x6 (R.Buf_48k_Out_Work_Q, LPF72_coeff_Interpolation, R.Buf_48k_Out_Q); // Применяем интерполятор.
      shift_buf (R.Buf_48k_Out_Work, 12);                                       // Сдвиг буфера интерполятора на 1 отсчет
      shift_buf (R.Buf_48k_Out_Work_Q, 12);                                     // Сдвиг буфера интерполятора на 1 отсчет
      
      for (uint8_t i=0;i<6;i++){                                                // Для каждого интерполированного отсчета
        dds16(&R.DDS_TX);                                                       // Генерируем два отсчета I и Q
        R.Buf_48k_Out[i]   *= R.DDS_TX.Q;                                       // Домножаем квадратурно на несущую
        R.Buf_48k_Out_Q[i] *= R.DDS_TX.I;
        R.Buf_48k_Out[i]   += R.Buf_48k_Out_Q[i];                               // Формируем выходной сигнал
      }
  }// Конец домена 8 кГц


  return set_PWR (R.SSB_Out_F, R.TX_pwr);
}




//******************************************************************************
//   Загрузка буфера для FFT
//******************************************************************************
/*
Вызывается с частотой 48 кГц.
Если буфер свободен (нет флага "Буфер полон" - набираем в него 1024 отсчета.
Как только буфер набран - ставим флаг "Буфер полон"
В основном кольце программы работает функция fft_routine, которая обрабатывает буфер. 
После выполнения FFТ, анализа данных и отправки на сервер, снимается флаг "Буфер полон" 
и начинается сбор новых данных.
*/
static int16_t fft_load (int16_t In){
  
//  if (R.FFT_full == 1)  return In;
//  
//  R.FFT_buf[R.FFT_idx++] = In;                                                  // Сохраняем в буфер значение
//  R.FFT_buf[R.FFT_idx++] = 0;
//  
//  if (R.FFT_idx == 2048){                                                       // Если буфер заполнен
//    R.FFT_idx = 0;                                                              // Обнуляем индекс
//    R.FFT_full = 1;                                                             // Ставим флаг готовности буфера к обработке
//  };

  
  return In;
}




//******************************************************************************
// Сдвиг буфера размером SIZE на 1 элемент назад
//******************************************************************************
static void shift_buf (float *in, uint16_t size) {
  uint16_t i;
  
  for (i=0; i<size; i++) {
    *(in + i) = *(in + i + 1);
  }
  
}


//******************************************************************************
// Сдвиг буфера размером 128 на 1 элемент назад
//******************************************************************************
static void shift_buf_128 (float *In) {
  *(In +	0	) = *(In + 	1	);
  *(In +	1	) = *(In + 	2	);
  *(In +	2	) = *(In + 	3	);
  *(In +	3	) = *(In + 	4	);
  *(In +	4	) = *(In + 	5	);
  *(In +	5	) = *(In + 	6	);
  *(In +	6	) = *(In + 	7	);
  *(In +	7	) = *(In + 	8	);
  *(In +	8	) = *(In + 	9	);
  *(In +	9	) = *(In + 	10	);
  *(In +	10	) = *(In + 	11	);
  *(In +	11	) = *(In + 	12	);
  *(In +	12	) = *(In + 	13	);
  *(In +	13	) = *(In + 	14	);
  *(In +	14	) = *(In + 	15	);
  *(In +	15	) = *(In + 	16	);
  *(In +	16	) = *(In + 	17	);
  *(In +	17	) = *(In + 	18	);
  *(In +	18	) = *(In + 	19	);
  *(In +	19	) = *(In + 	20	);
  *(In +	20	) = *(In + 	21	);
  *(In +	21	) = *(In + 	22	);
  *(In +	22	) = *(In + 	23	);
  *(In +	23	) = *(In + 	24	);
  *(In +	24	) = *(In + 	25	);
  *(In +	25	) = *(In + 	26	);
  *(In +	26	) = *(In + 	27	);
  *(In +	27	) = *(In + 	28	);
  *(In +	28	) = *(In + 	29	);
  *(In +	29	) = *(In + 	30	);
  *(In +	30	) = *(In + 	31	);
  *(In +	31	) = *(In + 	32	);
  *(In +	32	) = *(In + 	33	);
  *(In +	33	) = *(In + 	34	);
  *(In +	34	) = *(In + 	35	);
  *(In +	35	) = *(In + 	36	);
  *(In +	36	) = *(In + 	37	);
  *(In +	37	) = *(In + 	38	);
  *(In +	38	) = *(In + 	39	);
  *(In +	39	) = *(In + 	40	);
  *(In +	40	) = *(In + 	41	);
  *(In +	41	) = *(In + 	42	);
  *(In +	42	) = *(In + 	43	);
  *(In +	43	) = *(In + 	44	);
  *(In +	44	) = *(In + 	45	);
  *(In +	45	) = *(In + 	46	);
  *(In +	46	) = *(In + 	47	);
  *(In +	47	) = *(In + 	48	);
  *(In +	48	) = *(In + 	49	);
  *(In +	49	) = *(In + 	50	);
  *(In +	50	) = *(In + 	51	);
  *(In +	51	) = *(In + 	52	);
  *(In +	52	) = *(In + 	53	);
  *(In +	53	) = *(In + 	54	);
  *(In +	54	) = *(In + 	55	);
  *(In +	55	) = *(In + 	56	);
  *(In +	56	) = *(In + 	57	);
  *(In +	57	) = *(In + 	58	);
  *(In +	58	) = *(In + 	59	);
  *(In +	59	) = *(In + 	60	);
  *(In +	60	) = *(In + 	61	);
  *(In +	61	) = *(In + 	62	);
  *(In +	62	) = *(In + 	63	);
  *(In +	63	) = *(In + 	64	);
  *(In +	64	) = *(In + 	65	);
  *(In +	65	) = *(In + 	66	);
  *(In +	66	) = *(In + 	67	);
  *(In +	67	) = *(In + 	68	);
  *(In +	68	) = *(In + 	69	);
  *(In +	69	) = *(In + 	70	);
  *(In +	70	) = *(In + 	71	);
  *(In +	71	) = *(In + 	72	);
  *(In +	72	) = *(In + 	73	);
  *(In +	73	) = *(In + 	74	);
  *(In +	74	) = *(In + 	75	);
  *(In +	75	) = *(In + 	76	);
  *(In +	76	) = *(In + 	77	);
  *(In +	77	) = *(In + 	78	);
  *(In +	78	) = *(In + 	79	);
  *(In +	79	) = *(In + 	80	);
  *(In +	80	) = *(In + 	81	);
  *(In +	81	) = *(In + 	82	);
  *(In +	82	) = *(In + 	83	);
  *(In +	83	) = *(In + 	84	);
  *(In +	84	) = *(In + 	85	);
  *(In +	85	) = *(In + 	86	);
  *(In +	86	) = *(In + 	87	);
  *(In +	87	) = *(In + 	88	);
  *(In +	88	) = *(In + 	89	);
  *(In +	89	) = *(In + 	90	);
  *(In +	90	) = *(In + 	91	);
  *(In +	91	) = *(In + 	92	);
  *(In +	92	) = *(In + 	93	);
  *(In +	93	) = *(In + 	94	);
  *(In +	94	) = *(In + 	95	);
  *(In +	95	) = *(In + 	96	);
  *(In +	96	) = *(In + 	97	);
  *(In +	97	) = *(In + 	98	);
  *(In +	98	) = *(In + 	99	);
  *(In +	99	) = *(In + 	100	);
  *(In +	100	) = *(In + 	101	);
  *(In +	101	) = *(In + 	102	);
  *(In +	102	) = *(In + 	103	);
  *(In +	103	) = *(In + 	104	);
  *(In +	104	) = *(In + 	105	);
  *(In +	105	) = *(In + 	106	);
  *(In +	106	) = *(In + 	107	);
  *(In +	107	) = *(In + 	108	);
  *(In +	108	) = *(In + 	109	);
  *(In +	109	) = *(In + 	110	);
  *(In +	110	) = *(In + 	111	);
  *(In +	111	) = *(In + 	112	);
  *(In +	112	) = *(In + 	113	);
  *(In +	113	) = *(In + 	114	);
  *(In +	114	) = *(In + 	115	);
  *(In +	115	) = *(In + 	116	);
  *(In +	116	) = *(In + 	117	);
  *(In +	117	) = *(In + 	118	);
  *(In +	118	) = *(In + 	119	);
  *(In +	119	) = *(In + 	120	);
  *(In +	120	) = *(In + 	121	);
  *(In +	121	) = *(In + 	122	);
  *(In +	122	) = *(In + 	123	);
  *(In +	123	) = *(In + 	124	);
  *(In +	124	) = *(In + 	125	);
  *(In +	125	) = *(In + 	126	);
  *(In +	126	) = *(In + 	127	);
}



//******************************************************************************
// Сдвиг буфера размером 72 на 1 элемент назад
//******************************************************************************
static void shift_buf_72 (float *In) {
  *(In +	0	) = *(In + 	1	);
  *(In +	1	) = *(In + 	2	);
  *(In +	2	) = *(In + 	3	);
  *(In +	3	) = *(In + 	4	);
  *(In +	4	) = *(In + 	5	);
  *(In +	5	) = *(In + 	6	);
  *(In +	6	) = *(In + 	7	);
  *(In +	7	) = *(In + 	8	);
  *(In +	8	) = *(In + 	9	);
  *(In +	9	) = *(In + 	10	);
  *(In +	10	) = *(In + 	11	);
  *(In +	11	) = *(In + 	12	);
  *(In +	12	) = *(In + 	13	);
  *(In +	13	) = *(In + 	14	);
  *(In +	14	) = *(In + 	15	);
  *(In +	15	) = *(In + 	16	);
  *(In +	16	) = *(In + 	17	);
  *(In +	17	) = *(In + 	18	);
  *(In +	18	) = *(In + 	19	);
  *(In +	19	) = *(In + 	20	);
  *(In +	20	) = *(In + 	21	);
  *(In +	21	) = *(In + 	22	);
  *(In +	22	) = *(In + 	23	);
  *(In +	23	) = *(In + 	24	);
  *(In +	24	) = *(In + 	25	);
  *(In +	25	) = *(In + 	26	);
  *(In +	26	) = *(In + 	27	);
  *(In +	27	) = *(In + 	28	);
  *(In +	28	) = *(In + 	29	);
  *(In +	29	) = *(In + 	30	);
  *(In +	30	) = *(In + 	31	);
  *(In +	31	) = *(In + 	32	);
  *(In +	32	) = *(In + 	33	);
  *(In +	33	) = *(In + 	34	);
  *(In +	34	) = *(In + 	35	);
  *(In +	35	) = *(In + 	36	);
  *(In +	36	) = *(In + 	37	);
  *(In +	37	) = *(In + 	38	);
  *(In +	38	) = *(In + 	39	);
  *(In +	39	) = *(In + 	40	);
  *(In +	40	) = *(In + 	41	);
  *(In +	41	) = *(In + 	42	);
  *(In +	42	) = *(In + 	43	);
  *(In +	43	) = *(In + 	44	);
  *(In +	44	) = *(In + 	45	);
  *(In +	45	) = *(In + 	46	);
  *(In +	46	) = *(In + 	47	);
  *(In +	47	) = *(In + 	48	);
  *(In +	48	) = *(In + 	49	);
  *(In +	49	) = *(In + 	50	);
  *(In +	50	) = *(In + 	51	);
  *(In +	51	) = *(In + 	52	);
  *(In +	52	) = *(In + 	53	);
  *(In +	53	) = *(In + 	54	);
  *(In +	54	) = *(In + 	55	);
  *(In +	55	) = *(In + 	56	);
  *(In +	56	) = *(In + 	57	);
  *(In +	57	) = *(In + 	58	);
  *(In +	58	) = *(In + 	59	);
  *(In +	59	) = *(In + 	60	);
  *(In +	60	) = *(In + 	61	);
  *(In +	61	) = *(In + 	62	);
  *(In +	62	) = *(In + 	63	);
  *(In +	63	) = *(In + 	64	);
  *(In +	64	) = *(In + 	65	);
  *(In +	65	) = *(In + 	66	);
  *(In +	66	) = *(In + 	67	);
  *(In +	67	) = *(In + 	68	);
  *(In +	68	) = *(In + 	69	);
  *(In +	69	) = *(In + 	70	);
  *(In +	70	) = *(In + 	71	);
  *(In +	71	) = *(In + 	72	);
}





//******************************************************************************
// Сдвиг буфера размером 72 на 6 элементов назад
//******************************************************************************
static void shift_buf_72_6 (float *In) {
    *(In +	0	) = *(In + 	6	);
    *(In +	1	) = *(In + 	7	);
    *(In +	2	) = *(In + 	8	);
    *(In +	3	) = *(In + 	9	);
    *(In +	4	) = *(In + 	10	);
    *(In +	5	) = *(In + 	11	);
    *(In +	6	) = *(In + 	12	);
    *(In +	7	) = *(In + 	13	);
    *(In +	8	) = *(In + 	14	);
    *(In +	9	) = *(In + 	15	);
    *(In +	10	) = *(In + 	16	);
    *(In +	11	) = *(In + 	17	);
    *(In +	12	) = *(In + 	18	);
    *(In +	13	) = *(In + 	19	);
    *(In +	14	) = *(In + 	20	);
    *(In +	15	) = *(In + 	21	);
    *(In +	16	) = *(In + 	22	);
    *(In +	17	) = *(In + 	23	);
    *(In +	18	) = *(In + 	24	);
    *(In +	19	) = *(In + 	25	);
    *(In +	20	) = *(In + 	26	);
    *(In +	21	) = *(In + 	27	);
    *(In +	22	) = *(In + 	28	);
    *(In +	23	) = *(In + 	29	);
    *(In +	24	) = *(In + 	30	);
    *(In +	25	) = *(In + 	31	);
    *(In +	26	) = *(In + 	32	);
    *(In +	27	) = *(In + 	33	);
    *(In +	28	) = *(In + 	34	);
    *(In +	29	) = *(In + 	35	);
    *(In +	30	) = *(In + 	36	);
    *(In +	31	) = *(In + 	37	);
    *(In +	32	) = *(In + 	38	);
    *(In +	33	) = *(In + 	39	);
    *(In +	34	) = *(In + 	40	);
    *(In +	35	) = *(In + 	41	);
    *(In +	36	) = *(In + 	42	);
    *(In +	37	) = *(In + 	43	);
    *(In +	38	) = *(In + 	44	);
    *(In +	39	) = *(In + 	45	);
    *(In +	40	) = *(In + 	46	);
    *(In +	41	) = *(In + 	47	);
    *(In +	42	) = *(In + 	48	);
    *(In +	43	) = *(In + 	49	);
    *(In +	44	) = *(In + 	50	);
    *(In +	45	) = *(In + 	51	);
    *(In +	46	) = *(In + 	52	);
    *(In +	47	) = *(In + 	53	);
    *(In +	48	) = *(In + 	54	);
    *(In +	49	) = *(In + 	55	);
    *(In +	50	) = *(In + 	56	);
    *(In +	51	) = *(In + 	57	);
    *(In +	52	) = *(In + 	58	);
    *(In +	53	) = *(In + 	59	);
    *(In +	54	) = *(In + 	60	);
    *(In +	55	) = *(In + 	61	);
    *(In +	56	) = *(In + 	62	);
    *(In +	57	) = *(In + 	63	);
    *(In +	58	) = *(In + 	64	);
    *(In +	59	) = *(In + 	65	);
    *(In +	60	) = *(In + 	66	);
    *(In +	61	) = *(In + 	67	);
    *(In +	62	) = *(In + 	68	);
    *(In +	63	) = *(In + 	69	);
    *(In +	64	) = *(In + 	70	);
    *(In +	65	) = *(In + 	71	);
}




//******************************************************************************
// Сдвиг буфера размером 32 на 1 элемент назад
//******************************************************************************
static void shift_buf_32 (float *In) {
  *(In +	0	) = *(In + 	1	);
  *(In +	1	) = *(In + 	2	);
  *(In +	2	) = *(In + 	3	);
  *(In +	3	) = *(In + 	4	);
  *(In +	4	) = *(In + 	5	);
  *(In +	5	) = *(In + 	6	);
  *(In +	6	) = *(In + 	7	);
  *(In +	7	) = *(In + 	8	);
  *(In +	8	) = *(In + 	9	);
  *(In +	9	) = *(In + 	10	);
  *(In +	10	) = *(In + 	11	);
  *(In +	11	) = *(In + 	12	);
  *(In +	12	) = *(In + 	13	);
  *(In +	13	) = *(In + 	14	);
  *(In +	14	) = *(In + 	15	);
  *(In +	15	) = *(In + 	16	);
  *(In +	16	) = *(In + 	17	);
  *(In +	17	) = *(In + 	18	);
  *(In +	18	) = *(In + 	19	);
  *(In +	19	) = *(In + 	20	);
  *(In +	20	) = *(In + 	21	);
  *(In +	21	) = *(In + 	22	);
  *(In +	22	) = *(In + 	23	);
  *(In +	23	) = *(In + 	24	);
  *(In +	24	) = *(In + 	25	);
  *(In +	25	) = *(In + 	26	);
  *(In +	26	) = *(In + 	27	);
  *(In +	27	) = *(In + 	28	);
  *(In +	28	) = *(In + 	29	);
  *(In +	29	) = *(In + 	30	);
  *(In +	30	) = *(In + 	31	);
  
}



//******************************************************************************
// Сдвиг буфера размером 32 на 6 элементов назад
//******************************************************************************
static void shift_buf_32_6 (float *In) {
  *(In +	0	) = *(In + 	6	);
  *(In +	1	) = *(In + 	7	);
  *(In +	2	) = *(In + 	8	);
  *(In +	3	) = *(In + 	9	);
  *(In +	4	) = *(In + 	10	);
  *(In +	5	) = *(In + 	11	);
  *(In +	6	) = *(In + 	12	);
  *(In +	7	) = *(In + 	13	);
  *(In +	8	) = *(In + 	14	);
  *(In +	9	) = *(In + 	15	);
  *(In +	10	) = *(In + 	16	);
  *(In +	11	) = *(In + 	17	);
  *(In +	12	) = *(In + 	18	);
  *(In +	13	) = *(In + 	19	);
  *(In +	14	) = *(In + 	20	);
  *(In +	15	) = *(In + 	21	);
  *(In +	16	) = *(In + 	22	);
  *(In +	17	) = *(In + 	23	);
  *(In +	18	) = *(In + 	24	);
  *(In +	19	) = *(In + 	25	);
  *(In +	20	) = *(In + 	26	);
  *(In +	21	) = *(In + 	27	);
  *(In +	22	) = *(In + 	28	);
  *(In +	23	) = *(In + 	29	);
  *(In +	24	) = *(In + 	30	);
  *(In +	25	) = *(In + 	31	);
  
}


static float LPF_128_SIN (float *in, float *coeff){
float Out = 0;  
    // SIN filter
    Out += (*(in +   1)) * (*(coeff +   1));
    Out -= (*(in +   3)) * (*(coeff +   3));
    Out += (*(in +   5)) * (*(coeff +   5));
    Out -= (*(in +   7)) * (*(coeff +   7));
    Out += (*(in +   9)) * (*(coeff +   9));
    Out -= (*(in +  11)) * (*(coeff +  11));
    Out += (*(in +  13)) * (*(coeff +  13));
    Out -= (*(in +  15)) * (*(coeff +  15));
    Out += (*(in +  17)) * (*(coeff +  17));
    Out -= (*(in +  19)) * (*(coeff +  19));
    Out += (*(in +  21)) * (*(coeff +  21));
    Out -= (*(in +  23)) * (*(coeff +  23));
    Out += (*(in +  25)) * (*(coeff +  25));
    Out -= (*(in +  27)) * (*(coeff +  27));
    Out += (*(in +  29)) * (*(coeff +  29));
    Out -= (*(in +  31)) * (*(coeff +  31));
    Out += (*(in +  33)) * (*(coeff +  33));
    Out -= (*(in +  35)) * (*(coeff +  35));
    Out += (*(in +  37)) * (*(coeff +  37));
    Out -= (*(in +  39)) * (*(coeff +  39));
    Out += (*(in +  41)) * (*(coeff +  41));
    Out -= (*(in +  43)) * (*(coeff +  43));
    Out += (*(in +  45)) * (*(coeff +  45));
    Out -= (*(in +  47)) * (*(coeff +  47));
    Out += (*(in +  49)) * (*(coeff +  49));
    Out -= (*(in +  51)) * (*(coeff +  51));
    Out += (*(in +  53)) * (*(coeff +  53));
    Out -= (*(in +  55)) * (*(coeff +  55));
    Out += (*(in +  57)) * (*(coeff +  57));
    Out -= (*(in +  59)) * (*(coeff +  59));
    Out += (*(in +  61)) * (*(coeff +  61));
    Out -= (*(in +  63)) * (*(coeff +  63));
    Out += (*(in +  65)) * (*(coeff +  65));
    Out -= (*(in +  67)) * (*(coeff +  67));
    Out += (*(in +  69)) * (*(coeff +  69));
    Out -= (*(in +  71)) * (*(coeff +  71));
    Out += (*(in +  73)) * (*(coeff +  73));
    Out -= (*(in +  75)) * (*(coeff +  75));
    Out += (*(in +  77)) * (*(coeff +  77));
    Out -= (*(in +  79)) * (*(coeff +  79));
    Out += (*(in +  81)) * (*(coeff +  81));
    Out -= (*(in +  83)) * (*(coeff +  83));
    Out += (*(in +  85)) * (*(coeff +  85));
    Out -= (*(in +  87)) * (*(coeff +  87));
    Out += (*(in +  89)) * (*(coeff +  89));
    Out -= (*(in +  91)) * (*(coeff +  91));
    Out += (*(in +  93)) * (*(coeff +  93));
    Out -= (*(in +  95)) * (*(coeff +  95));
    Out += (*(in +  97)) * (*(coeff +  97));
    Out -= (*(in +  99)) * (*(coeff +  99));
    Out += (*(in + 101)) * (*(coeff + 101));
    Out -= (*(in + 103)) * (*(coeff + 103));
    Out += (*(in + 105)) * (*(coeff + 105));
    Out -= (*(in + 107)) * (*(coeff + 107));
    Out += (*(in + 109)) * (*(coeff + 109));
    Out -= (*(in + 111)) * (*(coeff + 111));
    Out += (*(in + 113)) * (*(coeff + 113));
    Out -= (*(in + 115)) * (*(coeff + 115));
    Out += (*(in + 117)) * (*(coeff + 117));
    Out -= (*(in + 119)) * (*(coeff + 119));
    Out += (*(in + 121)) * (*(coeff + 121));
    Out -= (*(in + 123)) * (*(coeff + 123));
    Out += (*(in + 125)) * (*(coeff + 125));
    Out -= (*(in + 127)) * (*(coeff + 127));
    
    return Out;
}

static float LPF_128_COS (float *in, float *coeff){
float Out = 0; 

    // COS filter
    Out += (*(in +   0)) * (*(coeff +   0));
    Out -= (*(in +   2)) * (*(coeff +   2));
    Out += (*(in +   4)) * (*(coeff +   4));
    Out -= (*(in +   6)) * (*(coeff +   6));
    Out += (*(in +   8)) * (*(coeff +   8));
    Out -= (*(in +  10)) * (*(coeff +  10));
    Out += (*(in +  12)) * (*(coeff +  12));
    Out -= (*(in +  14)) * (*(coeff +  14));
    Out += (*(in +  16)) * (*(coeff +  16));
    Out -= (*(in +  18)) * (*(coeff +  18));
    Out += (*(in +  20)) * (*(coeff +  20));
    Out -= (*(in +  22)) * (*(coeff +  22));
    Out += (*(in +  24)) * (*(coeff +  24));
    Out -= (*(in +  26)) * (*(coeff +  26));
    Out += (*(in +  28)) * (*(coeff +  28));
    Out -= (*(in +  30)) * (*(coeff +  30));
    Out += (*(in +  32)) * (*(coeff +  32));
    Out -= (*(in +  34)) * (*(coeff +  34));
    Out += (*(in +  36)) * (*(coeff +  36));
    Out -= (*(in +  38)) * (*(coeff +  38));
    Out += (*(in +  40)) * (*(coeff +  40));
    Out -= (*(in +  42)) * (*(coeff +  42));
    Out += (*(in +  44)) * (*(coeff +  44));
    Out -= (*(in +  46)) * (*(coeff +  46));
    Out += (*(in +  48)) * (*(coeff +  48));
    Out -= (*(in +  50)) * (*(coeff +  50));
    Out += (*(in +  52)) * (*(coeff +  52));
    Out -= (*(in +  54)) * (*(coeff +  54));
    Out += (*(in +  56)) * (*(coeff +  56));
    Out -= (*(in +  58)) * (*(coeff +  58));
    Out += (*(in +  60)) * (*(coeff +  60));
    Out -= (*(in +  62)) * (*(coeff +  62));
    Out += (*(in +  64)) * (*(coeff +  64));
    Out -= (*(in +  66)) * (*(coeff +  66));
    Out += (*(in +  68)) * (*(coeff +  68));
    Out -= (*(in +  70)) * (*(coeff +  70));
    Out += (*(in +  72)) * (*(coeff +  72));
    Out -= (*(in +  74)) * (*(coeff +  74));
    Out += (*(in +  76)) * (*(coeff +  76));
    Out -= (*(in +  78)) * (*(coeff +  78));
    Out += (*(in +  80)) * (*(coeff +  80));
    Out -= (*(in +  82)) * (*(coeff +  82));
    Out += (*(in +  84)) * (*(coeff +  84));
    Out -= (*(in +  86)) * (*(coeff +  86));
    Out += (*(in +  88)) * (*(coeff +  88));
    Out -= (*(in +  90)) * (*(coeff +  90));
    Out += (*(in +  92)) * (*(coeff +  92));
    Out -= (*(in +  94)) * (*(coeff +  94));
    Out += (*(in +  96)) * (*(coeff +  96));
    Out -= (*(in +  98)) * (*(coeff +  98));
    Out += (*(in + 100)) * (*(coeff + 100));
    Out -= (*(in + 102)) * (*(coeff + 102));
    Out += (*(in + 104)) * (*(coeff + 104));
    Out -= (*(in + 106)) * (*(coeff + 106));
    Out += (*(in + 108)) * (*(coeff + 108));
    Out -= (*(in + 110)) * (*(coeff + 110));
    Out += (*(in + 112)) * (*(coeff + 112));
    Out -= (*(in + 114)) * (*(coeff + 114));
    Out += (*(in + 116)) * (*(coeff + 116));
    Out -= (*(in + 118)) * (*(coeff + 118));
    Out += (*(in + 120)) * (*(coeff + 120));
    Out -= (*(in + 122)) * (*(coeff + 122));
    Out += (*(in + 124)) * (*(coeff + 124));
    Out -= (*(in + 126)) * (*(coeff + 126));
    
    return Out;
}


static float LPF_128 (float *in, float *coeff)
{
  float out1 = 0;
  
  out1 += (*(in +   0) * (*(coeff +   0)));
  out1 += (*(in +   1) * (*(coeff +   1)));
  out1 += (*(in +   2) * (*(coeff +   2)));
  out1 += (*(in +   3) * (*(coeff +   3)));
  out1 += (*(in +   4) * (*(coeff +   4)));
  out1 += (*(in +   5) * (*(coeff +   5)));
  out1 += (*(in +   6) * (*(coeff +   6)));
  out1 += (*(in +   7) * (*(coeff +   7)));
  out1 += (*(in +   8) * (*(coeff +   8)));
  out1 += (*(in +   9) * (*(coeff +   9)));
  out1 += (*(in +  10) * (*(coeff +  10)));
   
  out1 += (*(in +  11) * (*(coeff +  11)));
  out1 += (*(in +  12) * (*(coeff +  12)));
  out1 += (*(in +  13) * (*(coeff +  13)));
  out1 += (*(in +  14) * (*(coeff +  14)));
  out1 += (*(in +  15) * (*(coeff +  15)));
  out1 += (*(in +  16) * (*(coeff +  16)));
  out1 += (*(in +  17) * (*(coeff +  17)));
  out1 += (*(in +  18) * (*(coeff +  18)));
  out1 += (*(in +  19) * (*(coeff +  19)));
  out1 += (*(in +  20) * (*(coeff +  20)));
   
  out1 += (*(in +  21) * (*(coeff +  21)));
  out1 += (*(in +  22) * (*(coeff +  22)));
  out1 += (*(in +  23) * (*(coeff +  23)));
  out1 += (*(in +  24) * (*(coeff +  24)));
  out1 += (*(in +  25) * (*(coeff +  25)));
  out1 += (*(in +  26) * (*(coeff +  26)));
  out1 += (*(in +  27) * (*(coeff +  27)));
  out1 += (*(in +  28) * (*(coeff +  28)));
  out1 += (*(in +  29) * (*(coeff +  29)));
  out1 += (*(in +  30) * (*(coeff +  30)));
   
  out1 += (*(in +  31) * (*(coeff +  31)));
  out1 += (*(in +  32) * (*(coeff +  32)));
  out1 += (*(in +  33) * (*(coeff +  33)));
  out1 += (*(in +  34) * (*(coeff +  34)));
  out1 += (*(in +  35) * (*(coeff +  35)));
  out1 += (*(in +  36) * (*(coeff +  36)));
  out1 += (*(in +  37) * (*(coeff +  37)));
  out1 += (*(in +  38) * (*(coeff +  38)));
  out1 += (*(in +  39) * (*(coeff +  39)));
  out1 += (*(in +  40) * (*(coeff +  40)));
   
  out1 += (*(in +  41) * (*(coeff +  41)));
  out1 += (*(in +  42) * (*(coeff +  42)));
  out1 += (*(in +  43) * (*(coeff +  43)));
  out1 += (*(in +  44) * (*(coeff +  44)));
  out1 += (*(in +  45) * (*(coeff +  45)));
  out1 += (*(in +  46) * (*(coeff +  46)));
  out1 += (*(in +  47) * (*(coeff +  47)));
  out1 += (*(in +  48) * (*(coeff +  48)));
  out1 += (*(in +  49) * (*(coeff +  49)));
  out1 += (*(in +  50) * (*(coeff +  50)));
   
  out1 += (*(in +  51) * (*(coeff +  51)));
  out1 += (*(in +  52) * (*(coeff +  52)));
  out1 += (*(in +  53) * (*(coeff +  53)));
  out1 += (*(in +  54) * (*(coeff +  54)));
  out1 += (*(in +  55) * (*(coeff +  55)));
  out1 += (*(in +  56) * (*(coeff +  56)));
  out1 += (*(in +  57) * (*(coeff +  57)));
  out1 += (*(in +  58) * (*(coeff +  58)));
  out1 += (*(in +  59) * (*(coeff +  59)));
  out1 += (*(in +  60) * (*(coeff +  60)));
   
  out1 += (*(in +  61) * (*(coeff +  61)));
  out1 += (*(in +  62) * (*(coeff +  62)));
  out1 += (*(in +  63) * (*(coeff +  63)));
  out1 += (*(in +  64) * (*(coeff +  64)));
  out1 += (*(in +  65) * (*(coeff +  65)));
  out1 += (*(in +  66) * (*(coeff +  66)));
  out1 += (*(in +  67) * (*(coeff +  67)));
  out1 += (*(in +  68) * (*(coeff +  68)));
  out1 += (*(in +  69) * (*(coeff +  69)));
  out1 += (*(in +  70) * (*(coeff +  70)));
   
  out1 += (*(in +  71) * (*(coeff +  71)));
  out1 += (*(in +  72) * (*(coeff +  72)));
  out1 += (*(in +  73) * (*(coeff +  73)));
  out1 += (*(in +  74) * (*(coeff +  74)));
  out1 += (*(in +  75) * (*(coeff +  75)));
  out1 += (*(in +  76) * (*(coeff +  76)));
  out1 += (*(in +  77) * (*(coeff +  77)));
  out1 += (*(in +  78) * (*(coeff +  78)));
  out1 += (*(in +  79) * (*(coeff +  79)));
  out1 += (*(in +  80) * (*(coeff +  80)));
   
  out1 += (*(in +  81) * (*(coeff +  81)));
  out1 += (*(in +  82) * (*(coeff +  82)));
  out1 += (*(in +  83) * (*(coeff +  83)));
  out1 += (*(in +  84) * (*(coeff +  84)));
  out1 += (*(in +  85) * (*(coeff +  85)));
  out1 += (*(in +  86) * (*(coeff +  86)));
  out1 += (*(in +  87) * (*(coeff +  87)));
  out1 += (*(in +  88) * (*(coeff +  88)));
  out1 += (*(in +  89) * (*(coeff +  89)));
  out1 += (*(in +  90) * (*(coeff +  90)));
   
  out1 += (*(in +  91) * (*(coeff +  91)));
  out1 += (*(in +  92) * (*(coeff +  92)));
  out1 += (*(in +  93) * (*(coeff +  93)));
  out1 += (*(in +  94) * (*(coeff +  94)));
  out1 += (*(in +  95) * (*(coeff +  95)));
  out1 += (*(in +  96) * (*(coeff +  96)));
  out1 += (*(in +  97) * (*(coeff +  97)));
  out1 += (*(in +  98) * (*(coeff +  98)));
  out1 += (*(in +  99) * (*(coeff +  99)));
  out1 += (*(in + 100) * (*(coeff + 100)));
   
  out1 += (*(in + 101) * (*(coeff + 101)));
  out1 += (*(in + 102) * (*(coeff + 102)));
  out1 += (*(in + 103) * (*(coeff + 103)));
  out1 += (*(in + 104) * (*(coeff + 104)));
  out1 += (*(in + 105) * (*(coeff + 105)));
  out1 += (*(in + 106) * (*(coeff + 106)));
  out1 += (*(in + 107) * (*(coeff + 107)));
  out1 += (*(in + 108) * (*(coeff + 108)));
  out1 += (*(in + 109) * (*(coeff + 109)));
  out1 += (*(in + 110) * (*(coeff + 110)));
   
  out1 += (*(in + 111) * (*(coeff + 111)));
  out1 += (*(in + 112) * (*(coeff + 112)));
  out1 += (*(in + 113) * (*(coeff + 113)));
  out1 += (*(in + 114) * (*(coeff + 114)));
  out1 += (*(in + 115) * (*(coeff + 115)));
  out1 += (*(in + 116) * (*(coeff + 116)));
  out1 += (*(in + 117) * (*(coeff + 117)));
  out1 += (*(in + 118) * (*(coeff + 118)));
  out1 += (*(in + 119) * (*(coeff + 119)));
  out1 += (*(in + 120) * (*(coeff + 120)));
   
  out1 += (*(in + 121) * (*(coeff + 121)));
  out1 += (*(in + 122) * (*(coeff + 122)));
  out1 += (*(in + 123) * (*(coeff + 123)));
  out1 += (*(in + 124) * (*(coeff + 124)));
  out1 += (*(in + 125) * (*(coeff + 125)));
  out1 += (*(in + 126) * (*(coeff + 126)));
  out1 += (*(in + 127) * (*(coeff + 127)));
  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);

  return out1;  

}

static float LPF_72 (float *in, float *coeff)
{
  float out1 = 0;
  
  out1 += (*(in +   0) * (*(coeff +   0)));
  out1 += (*(in +   1) * (*(coeff +   1)));
  out1 += (*(in +   2) * (*(coeff +   2)));
  out1 += (*(in +   3) * (*(coeff +   3)));
  out1 += (*(in +   4) * (*(coeff +   4)));
  out1 += (*(in +   5) * (*(coeff +   5)));
  out1 += (*(in +   6) * (*(coeff +   6)));
  out1 += (*(in +   7) * (*(coeff +   7)));
  out1 += (*(in +   8) * (*(coeff +   8)));
  out1 += (*(in +   9) * (*(coeff +   9)));
  out1 += (*(in +  10) * (*(coeff +  10)));
   
  out1 += (*(in +  11) * (*(coeff +  11)));
  out1 += (*(in +  12) * (*(coeff +  12)));
  out1 += (*(in +  13) * (*(coeff +  13)));
  out1 += (*(in +  14) * (*(coeff +  14)));
  out1 += (*(in +  15) * (*(coeff +  15)));
  out1 += (*(in +  16) * (*(coeff +  16)));
  out1 += (*(in +  17) * (*(coeff +  17)));
  out1 += (*(in +  18) * (*(coeff +  18)));
  out1 += (*(in +  19) * (*(coeff +  19)));
  out1 += (*(in +  20) * (*(coeff +  20)));
   
  out1 += (*(in +  21) * (*(coeff +  21)));
  out1 += (*(in +  22) * (*(coeff +  22)));
  out1 += (*(in +  23) * (*(coeff +  23)));
  out1 += (*(in +  24) * (*(coeff +  24)));
  out1 += (*(in +  25) * (*(coeff +  25)));
  out1 += (*(in +  26) * (*(coeff +  26)));
  out1 += (*(in +  27) * (*(coeff +  27)));
  out1 += (*(in +  28) * (*(coeff +  28)));
  out1 += (*(in +  29) * (*(coeff +  29)));
  out1 += (*(in +  30) * (*(coeff +  30)));
   
  out1 += (*(in +  31) * (*(coeff +  31)));
  out1 += (*(in +  32) * (*(coeff +  32)));
  out1 += (*(in +  33) * (*(coeff +  33)));
  out1 += (*(in +  34) * (*(coeff +  34)));
  out1 += (*(in +  35) * (*(coeff +  35)));
  out1 += (*(in +  36) * (*(coeff +  36)));
  out1 += (*(in +  37) * (*(coeff +  37)));
  out1 += (*(in +  38) * (*(coeff +  38)));
  out1 += (*(in +  39) * (*(coeff +  39)));
  out1 += (*(in +  40) * (*(coeff +  40)));
   
  out1 += (*(in +  41) * (*(coeff +  41)));
  out1 += (*(in +  42) * (*(coeff +  42)));
  out1 += (*(in +  43) * (*(coeff +  43)));
  out1 += (*(in +  44) * (*(coeff +  44)));
  out1 += (*(in +  45) * (*(coeff +  45)));
  out1 += (*(in +  46) * (*(coeff +  46)));
  out1 += (*(in +  47) * (*(coeff +  47)));
  out1 += (*(in +  48) * (*(coeff +  48)));
  out1 += (*(in +  49) * (*(coeff +  49)));
  out1 += (*(in +  50) * (*(coeff +  50)));
   
  out1 += (*(in +  51) * (*(coeff +  51)));
  out1 += (*(in +  52) * (*(coeff +  52)));
  out1 += (*(in +  53) * (*(coeff +  53)));
  out1 += (*(in +  54) * (*(coeff +  54)));
  out1 += (*(in +  55) * (*(coeff +  55)));
  out1 += (*(in +  56) * (*(coeff +  56)));
  out1 += (*(in +  57) * (*(coeff +  57)));
  out1 += (*(in +  58) * (*(coeff +  58)));
  out1 += (*(in +  59) * (*(coeff +  59)));
  out1 += (*(in +  60) * (*(coeff +  60)));
   
  out1 += (*(in +  61) * (*(coeff +  61)));
  out1 += (*(in +  62) * (*(coeff +  62)));
  out1 += (*(in +  63) * (*(coeff +  63)));
  out1 += (*(in +  64) * (*(coeff +  64)));
  out1 += (*(in +  65) * (*(coeff +  65)));
  out1 += (*(in +  66) * (*(coeff +  66)));
  out1 += (*(in +  67) * (*(coeff +  67)));
  out1 += (*(in +  68) * (*(coeff +  68)));
  out1 += (*(in +  69) * (*(coeff +  69)));
  out1 += (*(in +  70) * (*(coeff +  70)));
   
  out1 += (*(in +  71) * (*(coeff +  71)));
  
  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++); // 16
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++); // 32
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++); // 48
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++); // 64
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++); // 72
  
  return out1;  

}


static float LPF_32 (float *in, float *coeff)
{
  float out1 = 0;

  out1 += (*(in +   0) * (*(coeff +   0)));
  out1 += (*(in +   1) * (*(coeff +   1)));
  out1 += (*(in +   2) * (*(coeff +   2)));
  out1 += (*(in +   3) * (*(coeff +   3)));
  out1 += (*(in +   4) * (*(coeff +   4)));
  out1 += (*(in +   5) * (*(coeff +   5)));
  out1 += (*(in +   6) * (*(coeff +   6)));
  out1 += (*(in +   7) * (*(coeff +   7)));
  out1 += (*(in +   8) * (*(coeff +   8)));
  out1 += (*(in +   9) * (*(coeff +   9)));
  out1 += (*(in +  10) * (*(coeff +  10)));
   
  out1 += (*(in +  11) * (*(coeff +  11)));
  out1 += (*(in +  12) * (*(coeff +  12)));
  out1 += (*(in +  13) * (*(coeff +  13)));
  out1 += (*(in +  14) * (*(coeff +  14)));
  out1 += (*(in +  15) * (*(coeff +  15)));
  out1 += (*(in +  16) * (*(coeff +  16)));
  out1 += (*(in +  17) * (*(coeff +  17)));
  out1 += (*(in +  18) * (*(coeff +  18)));
  out1 += (*(in +  19) * (*(coeff +  19)));
  out1 += (*(in +  20) * (*(coeff +  20)));
   
  out1 += (*(in +  21) * (*(coeff +  21)));
  out1 += (*(in +  22) * (*(coeff +  22)));
  out1 += (*(in +  23) * (*(coeff +  23)));
  out1 += (*(in +  24) * (*(coeff +  24)));
  out1 += (*(in +  25) * (*(coeff +  25)));
  out1 += (*(in +  26) * (*(coeff +  26)));
  out1 += (*(in +  27) * (*(coeff +  27)));
  out1 += (*(in +  28) * (*(coeff +  28)));
  out1 += (*(in +  29) * (*(coeff +  29)));
  out1 += (*(in +  30) * (*(coeff +  30)));
   
  out1 += (*(in +  31) * (*(coeff +  31)));


  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++); // 16
//  
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++);
//  out1 += (*in++) * (*coeff++); // 32
  
  return out1;  

}



static float LPF_128_I (float *in, float *coeff)
{
  float out1 = 0;

  in += 1; coeff += 1;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  //out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  
  return out1;  

}



static float LPF_128_Q (float *in, float *coeff)
{
  float out1 = 0;

  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;
  out1 += (*in)   * (*coeff);   in += 2; coeff += 2;

  return out1;  

}



//******************************************************************************
//   Фильтр интерполятор
//******************************************************************************
static void filter_interpolator_x6 (float *In, float *Coeff, float *Out){
float Out0=0, Out1=0, Out2=0, Out3=0, Out4=0, Out5=0;

    Out0 += *(Coeff + 71)  *   *(In + 11);
    Out0 += *(Coeff + 65)  *   *(In + 10);
    Out0 += *(Coeff + 59)  *   *(In + 9);
    Out0 += *(Coeff + 53)  *   *(In + 8);
    Out0 += *(Coeff + 47)  *   *(In + 7);
    Out0 += *(Coeff + 41)  *   *(In + 6);
    Out0 += *(Coeff + 35)  *   *(In + 5);
    Out0 += *(Coeff + 29)  *   *(In + 4);
    Out0 += *(Coeff + 23)  *   *(In + 3);
    Out0 += *(Coeff + 17)  *   *(In + 2);
    Out0 += *(Coeff + 11)  *   *(In + 1);
    Out0 += *(Coeff +  5)  *   *(In + 0);


    Out1 += *(Coeff + 70)  *   *(In + 11);
    Out1 += *(Coeff + 64)  *   *(In + 10);
    Out1 += *(Coeff + 58)  *   *(In + 9);
    Out1 += *(Coeff + 52)  *   *(In + 8);
    Out1 += *(Coeff + 46)  *   *(In + 7);
    Out1 += *(Coeff + 40)  *   *(In + 6);
    Out1 += *(Coeff + 34)  *   *(In + 5);
    Out1 += *(Coeff + 28)  *   *(In + 4);
    Out1 += *(Coeff + 22)  *   *(In + 3);
    Out1 += *(Coeff + 16)  *   *(In + 2);
    Out1 += *(Coeff + 10)  *   *(In + 1);
    Out1 += *(Coeff +  4)  *   *(In + 0);


    Out2 += *(Coeff + 69)  *   *(In + 11);
    Out2 += *(Coeff + 63)  *   *(In + 10);
    Out2 += *(Coeff + 57)  *   *(In + 9);
    Out2 += *(Coeff + 51)  *   *(In + 8);
    Out2 += *(Coeff + 45)  *   *(In + 7);
    Out2 += *(Coeff + 39)  *   *(In + 6);
    Out2 += *(Coeff + 33)  *   *(In + 5);
    Out2 += *(Coeff + 27)  *   *(In + 4);
    Out2 += *(Coeff + 21)  *   *(In + 3);
    Out2 += *(Coeff + 15)  *   *(In + 2);
    Out2 += *(Coeff +  9)  *   *(In + 1);
    Out2 += *(Coeff +  3)  *   *(In + 0);


    Out3 += *(Coeff + 68)  *   *(In + 11);
    Out3 += *(Coeff + 62)  *   *(In + 10);
    Out3 += *(Coeff + 56)  *   *(In + 9);
    Out3 += *(Coeff + 50)  *   *(In + 8);
    Out3 += *(Coeff + 44)  *   *(In + 7);
    Out3 += *(Coeff + 38)  *   *(In + 6);
    Out3 += *(Coeff + 32)  *   *(In + 5);
    Out3 += *(Coeff + 26)  *   *(In + 4);
    Out3 += *(Coeff + 20)  *   *(In + 3);
    Out3 += *(Coeff + 14)  *   *(In + 2);
    Out3 += *(Coeff +  8)  *   *(In + 1);
    Out3 += *(Coeff +  2)  *   *(In + 0);


    Out4 += *(Coeff + 67)  *   *(In + 11);
    Out4 += *(Coeff + 61)  *   *(In + 10);
    Out4 += *(Coeff + 55)  *   *(In + 9);
    Out4 += *(Coeff + 49)  *   *(In + 8);
    Out4 += *(Coeff + 43)  *   *(In + 7);
    Out4 += *(Coeff + 37)  *   *(In + 6);
    Out4 += *(Coeff + 31)  *   *(In + 5);
    Out4 += *(Coeff + 25)  *   *(In + 4);
    Out4 += *(Coeff + 19)  *   *(In + 3);
    Out4 += *(Coeff + 13)  *   *(In + 2);
    Out4 += *(Coeff +  7)  *   *(In + 1);
    Out4 += *(Coeff +  1)  *   *(In + 0);


    Out5 += *(Coeff + 66)  *   *(In + 11);
    Out5 += *(Coeff + 60)  *   *(In + 10);
    Out5 += *(Coeff + 54)  *   *(In + 9);
    Out5 += *(Coeff + 48)  *   *(In + 8);
    Out5 += *(Coeff + 42)  *   *(In + 7);
    Out5 += *(Coeff + 36)  *   *(In + 6);
    Out5 += *(Coeff + 30)  *   *(In + 5);
    Out5 += *(Coeff + 24)  *   *(In + 4);
    Out5 += *(Coeff + 18)  *   *(In + 3);
    Out5 += *(Coeff + 12)  *   *(In + 2);
    Out5 += *(Coeff +  6)  *   *(In + 1);
    Out5 += *(Coeff +  0)  *   *(In + 0);


    *(Out + 0) = Out0;
    *(Out + 1) = Out1;
    *(Out + 2) = Out2;
    *(Out + 3) = Out3;
    *(Out + 4) = Out4;
    *(Out + 5) = Out5;

}




//******************************************************************************
//   Фильтр показаний S метра.
//******************************************************************************
static uint32_t filter_S_meter (uint32_t In) {
static uint32_t Prev_out;
#define KS  4
uint32_t Out;
  Out = ((In + (Prev_out << KS)) - Prev_out) >> KS;
  Prev_out = Out;
return Out;  
}



//******************************************************************************
//   Конвертор показаний S-метра из попугаев в микровольты.
//******************************************************************************
static uint32_t convert_S_to_mkV (uint32_t In, RX_GAIN_t Gain){
uint32_t Out=0;  
    switch (Gain) {
    case RX_GAIN_LOW:
      if (In > 70){ Out = In/70; }
      break;
    case RX_GAIN_MED:
      if (In > 600){ Out = (In-200)/400; }
      break;
    case RX_GAIN_HIGH:
      if (In > 130){ Out = (In-50)/65; }
      break;
    default:
      break;
    }
return Out;    
}







//******************************************************************************
//   Сканирование тангенты и переключение режима. Вызываем через 1 мс
//******************************************************************************
/*
Однократное нажатие включает режим передачи голоса, двойное нажатие - передачу тона
При нажатии тангенты прибаваляем счетчик до времени, в котором можно чувствовать двойной клик
При отпускании начинаем прибавлять таймер отпускания
*/
void    rxtx_switch (void){
static uint16_t PushCnt, ReleaseCnt;
#define DBL_CLICK_TMR    300                                                    // ms
#define DEBOUNCE_TMR     10                                                     // ms

  
  if (HAL_GPIO_ReadPin(PTT1_GPIO_Port, PTT1_Pin) == GPIO_PIN_RESET){              // Если нажата тангента
    if (PushCnt < DBL_CLICK_TMR){
      PushCnt++;                                                                // Считаем время нажатого состояния
      if (PushCnt == DEBOUNCE_TMR){                                             // Если не помехи и точно нажатие
        if (ReleaseCnt < DBL_CLICK_TMR){                                        // Проверяем было ли отпускание
            //------------------------------------------------------------------ Double click routine
          R.TXRX_Mode = TX_TONE_1kHz;
          set_TXRX_mode(R.TXRX_Mode);
          //__LAMP_ON; $$$
          __no_operation();
          __no_operation();
          __no_operation();
        }
        else {
            //------------------------------------------------------------------ General PTT routine
          __LED2_ON;
          R.TXRX_Mode = TX;
          set_TXRX_mode(R.TXRX_Mode);
          //__LAMP_ON; $$$
          __no_operation();
          __no_operation();
          __no_operation();
        }
        ReleaseCnt = 0;     
      }
    }
  }
  else {                                                                        // Если тангента отпущена
    if (ReleaseCnt < DBL_CLICK_TMR){
      ReleaseCnt++;
      if (ReleaseCnt == DEBOUNCE_TMR){
        PushCnt = 0;
        //---------------------------------------------------------------------- Release PTT routine
        __LED2_OFF;
        R.TXRX_Mode = RX;
        //__LAMP_OFF; $$$
          set_TXRX_mode(R.TXRX_Mode);
        __no_operation();
        __no_operation();
        __no_operation();
      };
    }
  }
}  



static uint16_t filter_current_TX (uint16_t In) {
static uint32_t Prev_out;
uint8_t Ks = 3;
uint32_t Out;
  Out = ((In + (Prev_out << Ks)) - Prev_out) >> Ks;
  Prev_out = Out;
return Out;  
}

static uint16_t filter_current_PWR (uint16_t In) {
static uint32_t Prev_out;
uint8_t Ks = 3;
uint32_t Out;
  Out = ((In + (Prev_out << Ks)) - Prev_out) >> Ks;
  Prev_out = Out;
return Out;  
}


//******************************************************************************
//   Измерение тока передачи и напряжения питания АЦП 1. Вызывается с частотой 1 мс, измеряем каждые 0,1 С
//******************************************************************************
void adc1_scan (void) {
static uint8_t Tick;
#define CURRENT         0
#define PWR_CH          1
#define TEMP            2
#define VREF            3   


  if (++Tick < 100)     return;
  
  Tick = 0;
  //adc_sample_to_mV (uint16_t In, uint16_t RefADC)
  R.TX_current_AVG = adc_sample_to_mV (filter_current_TX(R.ADC1_buf[CURRENT]), R.ADC1_buf[VREF]);
  //R.TX_current_AVG =  R.TX_current_AVG * 1346 * 2 / 1000;                       // 1346 - корректировка, 2 - для измерительного резистора 10 мОм. При 20 мОм нужно 1 
  if (adc_sample_to_mV(R.ADC1_buf[CURRENT], R.ADC1_buf[VREF]) > R.TX_current_Peack) R.TX_current_Peack = adc_sample_to_mV(R.ADC1_buf[CURRENT], R.ADC1_buf[VREF]);
  
  R.CPU_temperature = R.ADC1_buf[TEMP];
  R.PWR_main_mV = adc_sample_to_mV (filter_current_PWR(R.ADC1_buf[PWR_CH]), R.ADC1_buf[VREF]);
  R.PWR_main_mV = (R.PWR_main_mV * 1095) / 1000;
  
  HAL_ADC_Stop_DMA(&hadc1);
  HAL_ADC_Start_DMA(&hadc1, (uint32_t*)R.ADC1_buf, 4); // Ch0(Current) Ch1(Vpwr) Temp Vref

} 




//******************************************************************************
//   Установить частоту приема и передачи
//******************************************************************************
void     load_freq_settings (uint8_t Cmd) {
static uint8_t Freq_num=0;

  if (Cmd == 1) {
    if (++Freq_num >= 3) { Freq_num = 0;}
    switch (Freq_num){
    case 0:
      R.DDS_RX.Freq = 5000;
      R.DDS_TX.Freq = 5000;
      R.Beep = BEEP_2x1;
      break;
    case 1:
      R.DDS_RX.Freq = 10000;
      R.DDS_TX.Freq = 10000;
      R.Beep = BEEP_2x2;
      break;
    case 2:
      R.DDS_RX.Freq = 15000;
      R.DDS_TX.Freq = 15000;
      R.Beep = BEEP_2x3;
      break;
    default:
      Freq_num = 0;
      break;
    }
  } // if (Cmd == 1)
}



//******************************************************************************
//   Перевод значения АЦП в милливольты по опорному напряжению
//******************************************************************************
// RefADC - измеренное в отсчетах АЦП опорное напряжение
static uint16_t adc_sample_to_mV (uint16_t In, uint16_t RefADC){
#define   MCU_V_REF   1220                                                      // MCU_V_REF - напряжение Vref контроллера фактическое в мВ
  return ((MCU_V_REF * In) / RefADC);
} 


//void beep_gen (BEEP_TYPE_t B);




//******************************************************************************
//    Автоматическое управление режимами передатчика при режиме попугая
//******************************************************************************
void parott_control (uint8_t Enable){
/*
Если попугай включен.  
Есть три режима. В каждом вычитываем буфер от 0 до конца.
Достижение конца буфера - сигнал для переключения режима.
При достижении конца буфера из рабочей программы просто выходим.
Все переключения только при факте достижения конца буфера.  
*/


  
  switch (R.Parott_State) {
    case START:
      break;
    case TONE_OUT:
      
      break;
    case REC:
      break;
    case PLAY:
      break;
  }
}                                          





//******************************************************************************
//    Регулировка выходного сигнала в процентах от 0 до 100
//******************************************************************************
static int16_t set_PWR (float In, int32_t Pwr){
float Tmp;

  if ((Pwr >= 0) && (Pwr <= 100)) {                                             // Если желаемая мощность в допустимых пределах
    Tmp = In * Pwr;
    Tmp /= 100;
  }
  
  return (int16_t)Tmp;
  
}


//******************************************************************************
//   Запись аудио на SD карту
//******************************************************************************
static void    uSD_audio_record         (float In){
int32_t Tmp;

  Tmp = In;
  Tmp >>= 8;
  if (Tmp >  127) Tmp =  127;                                                   // Проверка и исправление уровней входного сигнала
  if (Tmp < -127) Tmp = -127;
  
  R.SD_Rec_buf[R.SD_Rec_idx] = (int8_t)Tmp;                                     // Готовим буфер для записи на uSD карту
  R.SD_Rec_idx++;
  if (R.SD_Rec_idx == 4096)  {
    R.SD_Rec_Save = 1;                                                          // Первая половина буфера готова к записи
  };
  
  if (R.SD_Rec_idx == 8192){
    R.SD_Rec_Save = 2; 
    R.SD_Rec_idx = 0;                                                           // Вторая половина буфера готова к записи
  }; 
}



//******************************************************************************
//   Запись аудио на SD карту
//******************************************************************************
void record_audio_to_uSD(void){
                                                     
UINT Bytes;
FRESULT res;  

  if (R.SD_Rec_Save == 0) return;
  
  switch (R.SD_Rec_Save){                                                       // Записываем если не 0 
  case 1:
    if(f_mount(&SDFatFS, SDPath, 1) == FR_OK){                                  //подключаем флешку
      
      R.WriteSD = 1;                                                            // Для вывода сообщения в статусе
      __LED2_ON;
      
      uint8_t path[12];
      sprintf(path, "wav%2d%2d.pcm", DevID.b15_0, DevID.b16_31);
      path[11] = '\0';

      res = f_open (&SDFile, (char*)path, FA_WRITE | FA_OPEN_APPEND);           // открываем файл для записи в конец файла или если его нет, то создаем
      res = f_write(&SDFile, R.SD_Rec_buf, 4096, &Bytes);                       // Записать полубуфер в конец файла
      res = f_close(&SDFile);
    };
    break;
  case 2:
    if(f_mount(&SDFatFS, SDPath, 1) == FR_OK){                                  //подключаем флешку
      
      R.WriteSD = 1;                                                            // Для вывода сообщения в статусе
      __LED2_ON;
    
      uint8_t path[12];
      sprintf(path, "wav%2d%2d.pcm", DevID.b15_0, DevID.b16_31);
      path[11] = '\0';

      res = f_open (&SDFile, (char*)path, FA_WRITE | FA_OPEN_APPEND);           // открываем файл для записи в конец файла или если его нет, то создаем
      res = f_write(&SDFile, R.SD_Rec_buf+4096, 4096, &Bytes);                  // Записать полубуфер в конец файла
      res = f_close(&SDFile);
    };
    break;
  }
  R.SD_Rec_Save = 0;
}





//******************************************************************************
//    АРУ. Быстрая реакция на атаку, медленная на спад
//******************************************************************************
void AGC (float *in) {
static float m_AGCave;
float mag;
#define VOLUME 4000
  mag = fabs(*in);
  if( mag > m_AGCave )
    m_AGCave = (1.0-1.0/10.0)*m_AGCave + (1.0/10.0)*mag;
  else
    m_AGCave = (1.0-1.0/2000.0)*m_AGCave + (1.0/2000.0)*mag;
  if( m_AGCave >= 1 ) // divide signal by ave if not almost zero
    {
      *in = ((*in) * VOLUME) / m_AGCave;
    }
}





//******************************************************************************
//   Формирование выходного сигнала приемника из двух входов Right-Out SPK
//******************************************************************************
/*
Выходной сигнал для УНЧ идет из правого канала кодека. Правый канал идет из старшей
половины uint32. 
В зависимости от переключателя Ch:
#define SILENCE         0
#define MA              1
#define GA              2
#define MAGA            3 

формируется выходной сигнал. Для отдельных каналов просто переносится в старшую часть,
для совместного воспроизведения каналы складываются, ограничиваются и потом сдвигаются
в старшую половину выходного uint32 слова.

*/
static uint32_t create_RX_out (uint8_t Ch, float MA_Ch, float GA_Ch) {
uint32_t Out_u32 = 0; 
int16_t Tmp;

  switch (Ch){
    case 0:                                                                     // SILENCE
      Out_u32 = 0;
    break;
    
    case 1:                                                                     // MA 
      Tmp = (int16_t)MA_Ch;
      Out_u32 = Tmp << 16;
    break;
    
    case 2:                                                                     // GA
      Tmp = (int16_t)GA_Ch;
      Out_u32 = Tmp << 16;
    break;
    
    case 3:                                                                     // MAGA
      Tmp = (int16_t)(MA_Ch + GA_Ch);
      Out_u32 = Tmp << 16;
      if ((MA_Ch + GA_Ch) > 32000) {
        Tmp = 32000;
        Out_u32 = Tmp << 16;
      } 
      if ((MA_Ch + GA_Ch) < -32000) {
        Tmp = -32000;
        Out_u32 = Tmp << 16;
      }
    break;
  }

return Out_u32;
};                 


//******************************************************************************
// ENF OF FILE
//******************************************************************************